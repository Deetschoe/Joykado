<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Beatkami - Rhythm Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load configuration (try backend first, fallback to local) -->
    <script>
        // Try to load from backend first (for production)
        // This will be set synchronously before other scripts run
        (function() {
            const configScript = document.createElement('script');
            configScript.src = '/config.js';
            configScript.onerror = function() {
                // Fallback to local config.js if backend config not available
                const localConfig = document.createElement('script');
                localConfig.src = 'config.js';
                document.head.appendChild(localConfig);
            };
            document.head.appendChild(configScript);
        })();
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;700;900&display=swap');

        :root {
            --hit-zone-size: 140px;
            --note-speed: 2.5s; /* Time for note to fall */
            --hunter-green: #386641;
            --sage-green: #6a994e;
            --yellow-green: #a7c957;
            --champagne-mist: #f2e8cf;
            --blushed-brick: #bc4749;
            --beatkami-primary: #6a994e; /* Sage Green */
            --beatkami-accent: #bc4749; /* Blushed Brick */
            --beatkami-success: #a7c957; /* Yellow Green */
            --base-bg: #ffffff;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            font-family: 'Inter', sans-serif;
            background-color: var(--base-bg);
            background-image: radial-gradient(circle, rgba(56, 102, 65, 0.1) 1px, transparent 1px);
            background-size: 30px 30px;
            overflow: hidden;
            user-select: none;
        }
        
        /* Hide all file inputs - they're triggered by buttons */
        input[type="file"] {
            display: none !important;
        }

        /* --- Screens --- */
        .screen {
            display: none;
            width: 100vw;
            height: 100vh;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: absolute;
            top: 0; left: 0;
            transition: opacity 0.5s;
            z-index: 1;
        }
        .screen.active { display: flex; }

        /* --- Beatkami Menu Grid --- */
        .beatkami-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 30px;
        }

        .channel-btn {
            width: 250px;
            height: 180px;
            background: white;
            border-radius: 25px;
            border: 5px solid #ccc;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275), box-shadow 0.2s, border-color 0.2s;
            box-shadow: 0 8px 15px rgba(0,0,0,0.1);
            color: #333;
        }

        .channel-btn:hover {
            transform: scale(1.05);
            border-color: var(--beatkami-primary);
            box-shadow: 0 0 25px rgba(106, 153, 78, 0.7), 0 8px 20px rgba(0,0,0,0.2);
            color: var(--hunter-green);
        }
        
        /* Menu item navigation */
        .menu-item {
            cursor: pointer;
            outline: none;
            min-width: 200px;
        }
        .menu-item:focus,
        .menu-item.selected {
            border-color: var(--beatkami-primary) !important;
            color: var(--beatkami-primary) !important;
            box-shadow: 0 0 15px rgba(106, 153, 78, 0.5), 0 4px 10px rgba(0,0,0,0.2) !important;
            transform: translateY(-2px);
        }
        
        .channel-icon { font-size: 50px; margin-bottom: 10px; }
        .channel-text { font-size: 22px; font-weight: 700; }

        /* --- Global Beatkami Button Style --- */
        .beatkami-button {
            background: linear-gradient(145deg, #ffffff, var(--champagne-mist));
            border: 3px solid var(--sage-green);
            padding: 14px 35px;
            border-radius: 50px;
            font-size: 18px;
            cursor: pointer;
            margin: 8px;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            color: var(--hunter-green);
            box-shadow: 
                0 6px 15px rgba(56, 102, 65, 0.2),
                0 0 0 0 rgba(106, 153, 78, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.6);
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }
        
        .beatkami-button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(106, 153, 78, 0.2);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }
        
        .beatkami-button:hover::before {
            width: 300px;
            height: 300px;
        }
        
        .beatkami-button:hover {
            border-color: var(--yellow-green);
            color: var(--hunter-green);
            box-shadow: 
                0 0 25px rgba(167, 201, 87, 0.6),
                0 0 40px rgba(106, 153, 78, 0.4),
                0 8px 20px rgba(56, 102, 65, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
            transform: translateY(-3px) scale(1.05);
            background: linear-gradient(145deg, #ffffff, rgba(167, 201, 87, 0.2));
        }
        
        .beatkami-button:active { 
            transform: translateY(-1px) scale(1.02); 
            box-shadow: 0 4px 10px rgba(56, 102, 65, 0.3);
        }
        
        .beatkami-button span {
            position: relative;
            z-index: 1;
        }

        /* --- Game/Editor Interface --- */
        .game-area {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: flex-end; 
            padding-bottom: 5vh;
            background: #f0f0f0;
        }
        
        /* Dual monitor mode - larger game area */
        body.dual-monitor .game-area {
            padding-bottom: 2vh;
        }
        
        body.dual-monitor .hit-zone {
            width: calc(var(--hit-zone-size) * 1.5);
            height: calc(var(--hit-zone-size) * 1.5);
            bottom: 3vh;
        }
        
        body.dual-monitor .arrow-indicator {
            font-size: 56px;
        }
        
        body.dual-monitor .falling-note {
            width: 70px;
            height: 70px;
            font-size: 40px;
        }
        
        .player-lane {
            position: relative;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0 3%;
            width: 45%;
            max-width: 450px;
            border-left: 2px dashed rgba(0,0,0,0.1);
            border-right: 2px dashed rgba(0,0,0,0.1);
            box-sizing: border-box;
        }
        
        /* Character display in corner */
        .character-display {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 120px;
            height: 120px;
            z-index: 100;
            pointer-events: none;
        }
        
        .character-display img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
        }
        
        @keyframes character-bounce {
            0%, 100% { transform: translateY(0px) scale(1); }
            50% { transform: translateY(-15px) scale(1.05); }
        }
        
        .character-display.bouncing img {
            animation: character-bounce 0.6s ease-in-out infinite;
        }
        
        @keyframes character-miss {
            0% { transform: translateX(0px) rotate(0deg); }
            25% { transform: translateX(-10px) rotate(-5deg); }
            50% { transform: translateX(10px) rotate(5deg); }
            75% { transform: translateX(-10px) rotate(-5deg); }
            100% { transform: translateX(0px) rotate(0deg); }
        }
        
        .character-display.miss-shake img {
            animation: character-miss 0.4s ease-in-out;
        }
        
        @keyframes character-combo {
            0%, 100% { transform: scale(1) rotate(0deg); }
            25% { transform: scale(1.2) rotate(-5deg); }
            50% { transform: scale(1.3) rotate(5deg); }
            75% { transform: scale(1.2) rotate(-5deg); }
        }
        
        .character-display.combo-celebration img {
            animation: character-combo 0.5s ease-in-out;
        }
        
        /* Background color flicker on combo */
        @keyframes combo-flicker {
            0% { background: linear-gradient(135deg, #f2e8cf 0%, #e8d8b8 50%, #f2e8cf 100%); }
            10% { background: linear-gradient(135deg, #a7c957 0%, #6a994e 50%, #a7c957 100%); }
            20% { background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 50%, #ff6b6b 100%); }
            30% { background: linear-gradient(135deg, #4ecdc4 0%, #44a08d 50%, #4ecdc4 100%); }
            40% { background: linear-gradient(135deg, #ffe66d 0%, #ffd93d 50%, #ffe66d 100%); }
            50% { background: linear-gradient(135deg, #a8e6cf 0%, #88d8a3 50%, #a8e6cf 100%); }
            60% { background: linear-gradient(135deg, #ff9ff3 0%, #f368e0 50%, #ff9ff3 100%); }
            70% { background: linear-gradient(135deg, #54a0ff 0%, #2e86de 50%, #54a0ff 100%); }
            80% { background: linear-gradient(135deg, #ff6348 0%, #ff4757 50%, #ff6348 100%); }
            90% { background: linear-gradient(135deg, #ffd32a 0%, #ffc312 50%, #ffd32a 100%); }
            100% { background: linear-gradient(135deg, #f2e8cf 0%, #e8d8b8 50%, #f2e8cf 100%); }
        }
        
        body.combo-active {
            animation: combo-flicker 0.3s linear infinite;
        }
        
        body.combo-active .game-area {
            animation: combo-flicker 0.3s linear infinite;
        }

        .hit-zone {
            width: var(--hit-zone-size);
            height: var(--hit-zone-size);
            border-radius: 50%;
            border: 10px solid var(--beatkami-primary);
            position: absolute;
            bottom: 5vh; 
            left: 50%;
            transform: translateX(-50%);
            display: grid;
            grid-template-areas: ". up ." "left center right" ". down .";
            place-items: center;
            background: linear-gradient(145deg, #ffffff, var(--champagne-mist));
            box-shadow: 
                0 0 30px rgba(56, 102, 65, 0.3),
                0 0 50px rgba(106, 153, 78, 0.2),
                inset 0 0 15px rgba(255,255,255,0.6),
                inset 0 2px 4px rgba(0,0,0,0.1);
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-sizing: border-box;
        }
        
        .hit-zone::before {
            content: '';
            position: absolute;
            top: -5px;
            left: -5px;
            right: -5px;
            bottom: -5px;
            border-radius: 50%;
            background: conic-gradient(
                from 0deg,
                var(--beatkami-primary),
                var(--beatkami-success),
                var(--beatkami-primary),
                var(--beatkami-success),
                var(--beatkami-primary)
            );
            opacity: 0;
            transition: opacity 0.3s;
            z-index: -1;
            animation: rotate-border 3s linear infinite;
        }
        
        @keyframes rotate-border {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .hit-zone:hover::before,
        .hit-zone.good::before {
            opacity: 0.3;
        }
        
        /* Removed hit-zone-label - no longer showing P1/P2 labels */
        .hit-zone-label-old {
            position: absolute;
            bottom: -25px;
            font-weight: 700;
            color: #555;
            font-size: 16px;
        }

        /* Hit Zone Feedback */
        @keyframes shake {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            10%, 30%, 50%, 70%, 90% { transform: translate(-8px, 0) rotate(-2deg); }
            20%, 40%, 60%, 80% { transform: translate(8px, 0) rotate(2deg); }
        }
        
        @keyframes hit-pulse {
            0% { 
                transform: scale(1);
                box-shadow: 0 0 30px var(--beatkami-success);
            }
            50% { 
                transform: scale(1.1);
                box-shadow: 0 0 50px var(--beatkami-success), 0 0 70px rgba(167, 201, 87, 0.6);
            }
            100% { 
                transform: scale(1);
                box-shadow: 0 0 30px var(--beatkami-success);
            }
        }
        
        .hit-zone.miss {
            animation: shake 0.4s;
            border-color: var(--beatkami-accent) !important;
            box-shadow: 
                0 0 40px var(--beatkami-accent),
                0 0 60px rgba(188, 71, 73, 0.5),
                inset 0 0 20px rgba(188, 71, 73, 0.3) !important;
        }
        .hit-zone.good {
            animation: hit-pulse 0.3s ease-out;
            border-color: var(--beatkami-success) !important;
            box-shadow: 
                0 0 40px var(--beatkami-success),
                0 0 60px rgba(167, 201, 87, 0.5),
                inset 0 0 20px rgba(167, 201, 87, 0.3) !important;
        }

        .arrow-indicator {
            font-size: 42px;
            font-weight: 900;
            color: #bbb;
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            padding: 8px;
            line-height: 1;
            text-shadow: 
                0 0 10px rgba(0,0,0,0.3),
                0 2px 4px rgba(0,0,0,0.4),
                0 0 20px rgba(0,0,0,0.2);
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
            position: relative;
        }
        
        .arrow-indicator::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(106, 153, 78, 0.1) 0%, transparent 70%);
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s;
            z-index: -1;
        }
        
        .arrow-up { grid-area: up; }
        .arrow-down { grid-area: down; }
        .arrow-left { grid-area: left; }
        .arrow-right { grid-area: right; }

        /* Active Arrow Feedback with enhanced effects */
        .hit-zone.active-up .arrow-up { 
            color: var(--beatkami-accent); 
            transform: scale(1.5) rotate(-5deg);
            text-shadow: 
                0 0 20px var(--beatkami-accent),
                0 0 30px rgba(188, 71, 73, 0.6),
                0 4px 8px rgba(0,0,0,0.5);
            filter: drop-shadow(0 0 15px var(--beatkami-accent));
        }
        .hit-zone.active-up .arrow-up::before {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.5);
            background: radial-gradient(circle, rgba(188, 71, 73, 0.3) 0%, transparent 70%);
        }
        
        .hit-zone.active-down .arrow-down { 
            color: var(--beatkami-accent); 
            transform: scale(1.5) rotate(5deg);
            text-shadow: 
                0 0 20px var(--beatkami-accent),
                0 0 30px rgba(188, 71, 73, 0.6),
                0 4px 8px rgba(0,0,0,0.5);
            filter: drop-shadow(0 0 15px var(--beatkami-accent));
        }
        .hit-zone.active-down .arrow-down::before {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.5);
            background: radial-gradient(circle, rgba(188, 71, 73, 0.3) 0%, transparent 70%);
        }
        
        .hit-zone.active-left .arrow-left { 
            color: var(--beatkami-primary); 
            transform: scale(1.5) rotate(5deg);
            text-shadow: 
                0 0 20px var(--beatkami-primary),
                0 0 30px rgba(106, 153, 78, 0.6),
                0 4px 8px rgba(0,0,0,0.5);
            filter: drop-shadow(0 0 15px var(--beatkami-primary));
        }
        .hit-zone.active-left .arrow-left::before {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.5);
            background: radial-gradient(circle, rgba(106, 153, 78, 0.3) 0%, transparent 70%);
        }
        
        .hit-zone.active-right .arrow-right { 
            color: var(--beatkami-primary); 
            transform: scale(1.5) rotate(-5deg);
            text-shadow: 
                0 0 20px var(--beatkami-primary),
                0 0 30px rgba(106, 153, 78, 0.6),
                0 4px 8px rgba(0,0,0,0.5);
            filter: drop-shadow(0 0 15px var(--beatkami-primary));
        }
        .hit-zone.active-right .arrow-right::before {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.5);
            background: radial-gradient(circle, rgba(106, 153, 78, 0.3) 0%, transparent 70%);
        }
        
        /* Pulse animation for arrows */
        @keyframes arrow-pulse {
            0%, 100% { transform: scale(1.5) rotate(0deg); }
            50% { transform: scale(1.6) rotate(2deg); }
        }
        
        .hit-zone.active-up .arrow-up,
        .hit-zone.active-down .arrow-down,
        .hit-zone.active-left .arrow-left,
        .hit-zone.active-right .arrow-right {
            animation: arrow-pulse 0.3s ease-in-out;
        }

        /* --- Falling Notes --- */
        .falling-note {
            position: absolute;
            width: 55px; 
            height: 55px;
            border-radius: 15px;
            border: 5px solid white;
            box-shadow: 
                0 0 15px rgba(0,0,0,0.4),
                0 0 25px rgba(0,0,0,0.2),
                inset 0 2px 4px rgba(255,255,255,0.3);
            display: flex; 
            justify-content: center; 
            align-items: center;
            font-size: 32px;
            font-weight: 900;
            top: -60px; /* Start above screen */
            transform: translateX(-50%);
            transition: top var(--note-speed) linear; 
            z-index: 50;
            backdrop-filter: blur(5px);
            animation: note-glow 2s ease-in-out infinite;
        }
        
        @keyframes note-glow {
            0%, 100% { 
                box-shadow: 
                    0 0 15px rgba(0,0,0,0.4),
                    0 0 25px rgba(0,0,0,0.2),
                    inset 0 2px 4px rgba(255,255,255,0.3);
            }
            50% { 
                box-shadow: 
                    0 0 20px rgba(0,0,0,0.5),
                    0 0 35px rgba(0,0,0,0.3),
                    inset 0 2px 4px rgba(255,255,255,0.4);
            }
        }

        .note-up, .note-down { 
            background: linear-gradient(145deg, var(--beatkami-accent), #a03a3c); 
            color: white;
            border-color: rgba(255,255,255,0.9);
        }
        .note-left, .note-right { 
            background: linear-gradient(145deg, var(--beatkami-primary), #5a7a3e); 
            color: white;
            border-color: rgba(255,255,255,0.9);
        }
        
        /* Add rotation animation to falling notes */
        @keyframes note-rotate {
            0% { transform: translateX(-50%) rotate(0deg); }
            100% { transform: translateX(-50%) rotate(360deg); }
        }
        
        .falling-note {
            animation: note-glow 2s ease-in-out infinite, note-rotate 3s linear infinite;
        }
        
        /* Lane positioning for 1P/2P */
        .note-up { left: 50%; } 
        .note-down { left: 50%; } 
        .note-left { left: 50%; } 
        .note-right { left: 50%; } 

        /* Floating Score Text Feedback */
        .score-feedback {
            position: absolute;
            bottom: calc(5vh + var(--hit-zone-size) / 2);
            font-size: 40px;
            font-weight: 900;
            opacity: 0;
            pointer-events: none;
            text-shadow: 2px 2px 5px rgba(0,0,0,0.3);
            animation: float-up 1s ease-out forwards;
            z-index: 100;
        }
        .feedback-good { color: var(--beatkami-success); }
        .feedback-miss { color: var(--beatkami-accent); }
        .feedback-combo { 
            color: var(--yellow-green);
            font-size: 60px;
            font-weight: 900;
            text-shadow: 
                0 0 20px var(--yellow-green),
                0 0 40px rgba(167, 201, 87, 0.8), 
                0 0 60px rgba(167, 201, 87, 0.6),
                0 4px 8px rgba(0,0,0,0.5);
            animation: combo-glow 0.5s ease-out;
        }
        
        @keyframes combo-glow {
            0% { 
                transform: scale(0.5);
                opacity: 0;
            }
            50% {
                transform: scale(1.3);
            }
            100% { 
                transform: scale(1);
                opacity: 1;
            }
        }

        @keyframes float-up {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-50px); }
        }
        
        @keyframes sparkle {
            0%, 100% { opacity: 0; transform: scale(0) rotate(0deg); }
            50% { opacity: 1; transform: scale(1) rotate(180deg); }
        }
        
        .sparkle {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #FFD700;
            border-radius: 50%;
            pointer-events: none;
            z-index: 200;
            box-shadow: 0 0 10px #FFD700;
            animation: sparkle 0.6s ease-out forwards;
        }
        
        /* Volume slider styling */
        #music-volume {
            -webkit-appearance: none;
            appearance: none;
            background: #d1d5db;
            outline: none;
        }
        
        #music-volume::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--beatkami-primary);
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        #music-volume::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--beatkami-primary);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

    </style>
</head>
<body>

    <!-- === CUSTOM MESSAGE BOX === -->
    <div id="custom-message-box" class="fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-white p-6 rounded-2xl shadow-2xl text-center z-[1000] border-4 border-amber-500 max-w-lg hidden">
        <div id="message-content" class="mb-4 text-lg font-medium text-gray-700"></div>
        <div class="flex justify-center space-x-4">
            <button class="beatkami-button bg-blue-100 border-blue-400 text-blue-800 hover:bg-blue-200" onclick="hideMessage(false)"><span>OK</span></button>
            <button class="beatkami-button bg-red-100 border-red-400 text-red-800 hover:bg-red-200" id="message-cancel-btn" style="display: none;" onclick="hideMessage(true)"><span>Cancel</span></button>
        </div>
    </div>

    <!-- === COUNTDOWN OVERLAY === -->
    <div id="countdown-overlay" class="fixed inset-0 bg-black/70 flex justify-center items-center z-[500] hidden">
        <div id="countdown-number" class="text-[200px] text-white font-black drop-shadow-[0_0_40px_rgba(106,153,78,1)]">3</div>
    </div>

    <!-- === SCREEN: USERNAME ENTRY (Home Screen) === -->
    <div id="screen-username-entry" class="screen active">
        <div class="bg-white p-10 rounded-3xl shadow-2xl max-w-lg w-full text-center">
            <div class="mb-8">
                <img src="kami.png" alt="Beatkami Logo" style="max-width: 200px; max-height: 120px; width: auto; height: auto; object-fit: contain; display: block; margin: 0 auto; filter: drop-shadow(0 4px 8px rgba(56, 102, 65, 0.3));">
            </div>
            <h2 class="text-3xl text-gray-700 font-bold mb-4">Enter Your Username</h2>
            <p class="text-gray-500 mb-6">Use A/D to move, W/S to change letters, Enter to confirm</p>
            
            <div class="mb-6">
                <div id="username-display" class="text-6xl font-black mb-4" style="color: var(--hunter-green); letter-spacing: 0.2em;">
                    AAAAA
                </div>
                <div class="text-sm text-gray-500">Current letter: <span id="username-letter-index">0</span>/5</div>
            </div>
            
            <div class="mb-4">
                <div class="text-lg font-semibold text-gray-700 mb-2">Controls:</div>
                <div class="text-sm text-gray-600">
                    <div>A / ‚Üê : Move left</div>
                    <div>D / ‚Üí : Move right</div>
                    <div>W / ‚Üë : Previous letter</div>
                    <div>S / ‚Üì : Next letter</div>
                    <div>Enter : Confirm username</div>
                </div>
            </div>
        </div>
    </div>

    <!-- === SCREEN 1: MAIN MENU === -->
    <div id="screen-menu" class="screen">
        <div class="mb-8">
            <img src="kami.png" alt="Beatkami Logo" style="max-width: 200px; max-height: 120px; width: auto; height: auto; object-fit: contain; display: block; margin: 0 auto; filter: drop-shadow(0 4px 8px rgba(56, 102, 65, 0.3));">
        </div>
        <h1 class="text-4xl font-black mb-10 tracking-widest" style="color: var(--hunter-green); -webkit-text-stroke: 2px var(--sage-green); -webkit-text-fill-color: var(--yellow-green); text-shadow: 3px 3px 0px var(--hunter-green), 6px 6px 12px rgba(0,0,0,0.2);">BEATKAMI</h1>
        <div id="player-name-display" class="text-xl font-bold mb-4" style="color: var(--hunter-green);">Player: <span id="player-name-text">AAAAA</span></div>
        <div id="main-menu-options" class="flex flex-col gap-4 items-center">
            <div class="menu-item beatkami-button bg-blue-50 text-blue-700 border-blue-300" data-action="play" tabindex="0">
                <span>üéß Play Songs</span>
            </div>
            <div class="menu-item beatkami-button bg-yellow-50 text-yellow-700 border-yellow-300" data-action="scores" tabindex="0">
                <span>üèÜ Scores</span>
            </div>
            <div class="menu-item beatkami-button bg-gray-100 text-gray-600 border-gray-300" data-action="options" tabindex="0">
                <span>‚öôÔ∏è Options</span>
            </div>
            <div class="menu-item beatkami-button bg-gray-100 text-gray-600 border-gray-300" data-action="back-to-joykado" tabindex="0">
                ‚Üê Back to Joykado
            </div>
        </div>
        <p class="text-xs text-gray-400 mt-10">Use WASD/Arrows to navigate, Enter to select</p>
    </div>
    
    <!-- === SCREEN: CATEGORY SELECTION === -->
    <div id="screen-category-select" class="screen">
        <div class="bg-white p-10 rounded-3xl shadow-2xl max-w-2xl w-[90%] text-center">
            <h2 class="text-3xl text-gray-700 font-bold mb-6">Select Category</h2>
            <div id="category-list" class="flex flex-col gap-3 w-full max-h-96 overflow-y-auto p-4 bg-gray-50 rounded-lg border border-gray-200">
                <!-- Categories will be injected here -->
            </div>
            <br>
            <div class="menu-item beatkami-button bg-gray-100 text-gray-600 border-gray-300" data-action="back-to-menu" tabindex="0">Back</div>
        </div>
    </div>

    <!-- === SCREEN 2: CREATOR SETUP (Uploads) === -->
    <div id="screen-setup" class="screen">
        <div class="bg-white p-10 rounded-3xl shadow-2xl max-w-lg w-full text-center">
            <h2 id="setup-title" class="text-3xl text-gray-700 font-bold mb-4">Create New Beatmap</h2>
            <p class="text-gray-500 mb-6">First, upload your music file (use mouse).</p>
            
            <button class="beatkami-button bg-blue-50 text-blue-700 border-blue-300" onclick="document.getElementById('file-input-mp3').click()">
                <span>Select MP3 / Audio File</span>
            </button>
            <input type="file" id="file-input-mp3" accept="audio/*" style="display: none;">
            <div id="mp3-filename" class="mt-4 text-blue-600 font-medium">No file selected.</div>

            <div id="song-name-input" class="mt-6 hidden">
                <input type="text" id="new-song-name" placeholder="Enter Song Name (Required)" 
                       class="p-3 border-2 border-gray-300 rounded-lg w-full text-center focus:border-beatkami-primary focus:outline-none">
            </div>
            
            <div id="category-select" class="mt-4 hidden">
                <label class="block text-sm font-semibold text-gray-700 mb-2">Category:</label>
                <select id="song-category" class="p-2 border-2 border-gray-300 rounded-lg w-full text-center focus:border-beatkami-primary focus:outline-none">
                    <option value="HipHop">HipHop</option>
                    <option value="Anime">Anime</option>
                    <option value="JPOP">JPOP</option>
                    <option value="Rock">Rock</option>
                    <option value="Misc">Misc</option>
                </select>
            </div>
            
            <div id="difficulty-select" class="mt-4 hidden">
                <label class="block text-sm font-semibold text-gray-700 mb-2">Difficulty:</label>
                <select id="song-difficulty" class="p-2 border-2 border-gray-300 rounded-lg w-full text-center focus:border-beatkami-primary focus:outline-none">
                    <option value="Easy">Easy</option>
                    <option value="Medium" selected>Medium</option>
                    <option value="Hard">Hard</option>
                </select>
            </div>

            <br>
            <button id="start-editor-btn" class="beatkami-button bg-green-50 text-green-700 border-green-300 font-bold" style="display: none; visibility: hidden;">
                <span>Start Recording Beat</span>
            </button>
            <br>
            <div class="menu-item beatkami-button bg-gray-100 text-gray-600 border-gray-300" data-action="back-to-options" tabindex="0">Back to Options</div>
        </div>
    </div>

    <!-- === SCREEN: SONG SELECTION === -->
    <div id="screen-song-select" class="screen">
        <div class="bg-white p-10 rounded-3xl shadow-2xl max-w-2xl w-[90%] text-center">
            <h2 class="text-3xl text-gray-700 font-bold mb-2" id="category-title">Select a Song</h2>
            <p class="text-sm text-gray-500 mb-4" id="category-subtitle"></p>
            <div id="song-list-container" class="flex flex-col gap-3 w-full max-h-80 overflow-y-auto p-4 bg-gray-50 rounded-lg border border-gray-200">
                <!-- Songs will be injected here -->
                <div class="text-gray-500 py-4" id="no-songs-message">Loading songs...</div>
            </div>

            <br>
            <div class="menu-item beatkami-button bg-gray-100 text-gray-600 border-gray-300" data-action="back-to-category" tabindex="0">Back</div>
        </div>
    </div>
    
    <!-- === SCREEN: OPTIONS === -->
    <div id="screen-options" class="screen">
        <div class="bg-white p-10 rounded-3xl shadow-2xl max-w-lg w-full text-center">
            <h2 class="text-3xl text-gray-700 font-bold mb-6">Options</h2>
            
            <div class="mb-6">
                <div class="menu-item beatkami-button bg-purple-50 text-purple-700 border-purple-300 relative" id="volume-menu-item" tabindex="0" style="min-height: 80px; display: flex; align-items: center; justify-content: center;">
                    <div class="flex flex-col items-center w-full">
                        <div class="text-lg font-semibold mb-2">Music Volume</div>
                        <div class="w-full max-w-xs mx-auto flex items-center gap-2">
                            <span class="text-xs text-gray-500">‚óÄ</span>
                            <div class="flex-1 h-8 bg-gray-300 rounded-full overflow-hidden border-2 border-gray-400 relative">
                                <div class="h-full bg-blue-600 transition-all duration-100" id="options-music-volume-bar" style="width: 50%"></div>
                                <div class="absolute inset-0 flex items-center justify-center text-sm font-bold text-gray-700" id="options-volume-text">50%</div>
                            </div>
                            <span class="text-xs text-gray-500">‚ñ∂</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="mb-6">
                <div class="menu-item beatkami-button bg-blue-50 text-blue-700 border-blue-300" data-action="open-creator" tabindex="0">
                    <span>üìù Beatmap Creator</span>
                </div>
            </div>
            
            <div class="mb-6">
                <!-- <p class="text-gray-500 mb-3 text-sm">Upload external files (use mouse):</p> -->
                <!-- <div class="flex justify-center flex-wrap gap-2">
                    <button class="beatkami-button text-indigo-700 border-indigo-300 text-sm" onclick="document.getElementById('file-input-external-mp3').click()">Upload MP3</button>
                    <button class="beatkami-button text-orange-700 border-orange-300 text-sm" onclick="document.getElementById('file-input-map').click()">Upload Beatmap</button>
                </div> -->
                <input type="file" id="file-input-external-mp3" accept="audio/*" style="display: none;">
                <input type="file" id="file-input-map" accept=".json" style="display: none;">
                <div id="external-upload-status" class="mt-2 text-sm text-blue-600 font-medium"></div>
            </div>
            
            <div class="menu-item beatkami-button bg-gray-100 text-gray-600 border-gray-300" data-action="back-to-menu" tabindex="0">Back to Menu</div>
        </div>
    </div>


    <!-- === SCREEN: NAME ENTRY === -->
    <div id="screen-name-entry" class="screen">
        <div class="bg-white p-10 rounded-3xl shadow-2xl max-w-lg w-full text-center">
            <h2 class="text-3xl text-gray-700 font-bold mb-4">Enter Your Name</h2>
            <p class="text-gray-500 mb-6">Use A/D to navigate, Enter to confirm</p>
            
            <div class="mb-6">
                <div id="name-display" class="text-6xl font-black mb-4" style="color: var(--hunter-green); letter-spacing: 0.2em;">
                    AAAAA
                </div>
                <div class="text-sm text-gray-500">Current letter: <span id="current-letter-index">0</span>/5</div>
            </div>
            
            <div class="mb-4">
                <div class="text-lg font-semibold text-gray-700 mb-2">Controls:</div>
                <div class="text-sm text-gray-600">
                    <div>A / ‚Üê : Move left</div>
                    <div>D / ‚Üí : Move right</div>
                    <div>W / ‚Üë : Previous letter</div>
                    <div>S / ‚Üì : Next letter</div>
                    <div>Enter : Confirm name</div>
                </div>
            </div>
        </div>
    </div>

    <!-- === SCREEN: LEADERBOARD === -->
    <div id="screen-leaderboard" class="screen">
        <div class="bg-white p-10 rounded-3xl shadow-2xl max-w-4xl w-full text-center">
            <h2 class="text-4xl font-black mb-6" style="color: var(--hunter-green);">üèÜ LEADERBOARD</h2>
            
            <div class="mb-4">
                <select id="leaderboard-filter" class="p-2 border-2 border-gray-300 rounded-lg text-center">
                    <option value="all">All Songs</option>
                    <option value="HipHop">HipHop</option>
                    <option value="Anime">Anime</option>
                    <option value="JPOP">JPOP</option>
                    <option value="Rock">Rock</option>
                    <option value="Misc">Misc</option>
                </select>
            </div>
            
            <div id="leaderboard-list" class="flex flex-col gap-2 w-full max-h-96 overflow-y-auto p-4 bg-gray-50 rounded-lg border border-gray-200">
                <div class="text-gray-500 py-4">Loading leaderboard...</div>
            </div>
            
            <br>
            <div class="menu-item beatkami-button bg-gray-100 text-gray-600 border-gray-300" data-action="back-to-menu" tabindex="0">Back to Menu</div>
        </div>
    </div>

    <!-- === SCREEN 6: PLAYER SETUP (Player Count) === -->
    <div id="screen-player-setup" class="screen">
        <div class="bg-white p-10 rounded-3xl shadow-2xl max-w-lg w-full text-center">
            <h2 class="text-3xl text-gray-700 font-bold mb-4" id="player-setup-song-title"></h2>
            <p class="text-gray-500 mb-6">Choose the number of players:</p>

            <div class="flex justify-center space-x-4">
                <div class="menu-item beatkami-button text-blue-700 border-blue-300" data-action="set-player-1" tabindex="0">1 Player</div>
                <div class="menu-item beatkami-button text-red-700 border-red-300" data-action="set-player-2" tabindex="0">2 Players</div>
            </div>

            <div id="player-count-display" class="mt-4 text-xl font-bold text-gray-600"></div>

            <br>
            <button id="start-player-btn" class="beatkami-button bg-green-50 text-green-700 border-green-300 font-bold hidden">
                Start Game
            </button>
            <br>
            <button class="beatkami-button bg-gray-100 text-gray-600 border-gray-300" onclick="openSongSelection()">Change Song</button>
        </div>
    </div>


    <!-- === SCREEN 3: GAME / EDITOR INTERFACE === -->
    <div id="screen-game" class="screen">
        <div class="absolute top-0 left-0 right-0 h-16 bg-white/95 border-b border-gray-300 flex items-center justify-between px-6 z-10">
            <div id="mode-display" class="font-bold text-lg text-gray-700"></div>
            <div class="flex items-center w-1/3 mx-8">
                <div class="progress-container w-full h-6 bg-gray-300 rounded-full overflow-hidden shadow-inner border-2 border-gray-400">
                    <div class="progress-fill h-full w-0 bg-blue-600 transition-all duration-100" id="progress-bar"></div>
                </div>
            </div>
            <div id="time-display" class="font-bold text-lg text-gray-700">0:00</div>
        </div>
        
        <div id="score-display" class="absolute top-20 right-6 text-2xl font-bold text-gray-600 z-10">SCORE: 0</div>
        <div id="combo-display" class="absolute top-20 left-6 text-2xl font-bold text-gray-600 z-10" style="transition: all 0.2s ease-out;">COMBO: 0</div>

        <div class="game-area" id="game-area">
            <!-- Player 1 Lane -->
            <div class="player-lane" id="player-lane-1">
                <div class="character-display bouncing" id="character-1">
                    <img src="kami.png" alt="Kami Character" id="character-img-1" onerror="this.style.display='none';">
                </div>
                <div class="hit-zone" id="hit-zone-1">
                    <div class="arrow-indicator arrow-up" style="grid-area: up;">‚ñ≤</div>
                    <div class="arrow-indicator arrow-left" style="grid-area: left;">‚óÄ</div>
                    <div class="arrow-indicator arrow-down" style="grid-area: down;">‚ñº</div>
                    <div class="arrow-indicator arrow-right" style="grid-area: right;">‚ñ∂</div>
                </div>
                <!-- Floating Feedback for P1 is created here -->
            </div>

            <!-- Player 2 Lane (Hidden by default, shown in 2P mode) -->
            <div class="player-lane" id="player-lane-2" style="display:none;">
                <div class="character-display bouncing" id="character-2">
                    <img src="kami.png" alt="Kami Character" id="character-img-2" onerror="this.style.display='none';">
                </div>
                <div class="hit-zone" id="hit-zone-2">
                    <div class="arrow-indicator arrow-up" style="grid-area: up;">‚ñ≤</div>
                    <div class="arrow-indicator arrow-left" style="grid-area: left;">‚óÄ</div>
                    <div class="arrow-indicator arrow-down" style="grid-area: down;">‚ñº</div>
                    <div class="arrow-indicator arrow-right" style="grid-area: right;">‚ñ∂</div>
                </div>
                 <!-- Floating Feedback for P2 is created here -->
            </div>
        </div>

        <!-- Volume Control and Quit button in corner -->
        <div id="game-controls" class="absolute top-4 right-4 flex items-center gap-3 z-20 hidden">
            <div class="flex flex-col items-center bg-white/90 rounded-lg p-2 shadow-lg border border-gray-300">
                <label class="text-xs text-gray-600 font-medium mb-1">Music</label>
                <input type="range" id="music-volume" min="0" max="100" value="50" 
                       class="w-20 h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer"
                       oninput="updateMusicVolume(this.value)">
            </div>
            <button class="beatkami-button bg-red-100 text-red-700 border-red-300 text-sm" onclick="askQuit()">Quit</button>
        </div>
        <div id="instruction-text" class="absolute top-24 left-1/2 -translate-x-1/2 text-lg text-gray-600 font-semibold z-10 text-center px-4" style="text-shadow: 0 2px 4px rgba(0,0,0,0.1);"></div>
    </div>

    <!-- === SCREEN 4: EXPORT / RESULTS === -->
    <div id="screen-result" class="screen">
        <div class="bg-white p-10 rounded-3xl shadow-2xl max-w-lg w-full text-center">
            <h2 id="result-title" class="text-3xl text-gray-700 font-bold mb-4"></h2>
            <p id="result-message" class="text-gray-500 mb-6"></p>
            <br>
            <div class="menu-item beatkami-button bg-green-50 text-green-700 border-green-300 font-bold" data-action="back-to-menu" tabindex="0">Return to Menu</div>
        </div>
    </div>

<script>
    // === GLOBAL VARIABLES ===
    let appMode = 'menu'; // menu, editor, player, select, setup, results
    let playerCount = 0;
    let mainAudio = new Audio();
    let recordedNotes = []; // Stores { time: number, direction: string, player: number }
    let playNotes = []; // The beatmap to play
    let activeSong = null; // { name, mp3Url, beatmap }
    let isPlaying = false;
    let animationFrameId;
    let lastTime;

    // Timing Constants
    const NOTE_SPEED = 2.5; // Time (seconds) for note to fall
    const HIT_WINDOW = 0.15; // Hit window (seconds) before and after the beat time
    const SPAWN_OFFSET_TIME = NOTE_SPEED; // Notes spawn 'NOTE_SPEED' seconds before they should be hit

    // Game state
    let notesIndex1P = 0;  // Index for spawning P1 notes
    let notesIndex2P = 0;  // Index for spawning P2 notes
    let score = 0;
    let combo = 0;
    let maxCombo = 0;
    let activeNotesMap = new Map(); // Track active notes: noteIndex -> {element, noteData, player}
    let gameStartTime = 0; // Track when the game actually started
    let lastComboMilestone = 0; // Track last combo milestone shown
    let hasPlayedMissSound = false; // Track if miss sound has been played for current miss streak
    let comboSound = null; // Combo sound effect
    let missSound = null; // Miss sound effect
    let currentMp3File = null; // Store the original MP3 file for upload
    let originalMp3FileName = null; // Store the original filename
    let comboFlickerTimeout = null; // Timeout for combo background flicker
    let characterState = { 1: 'normal', 2: 'normal' }; // Track character state per player
    let scoreWindow = null; // Reference to score display window (dual monitor mode)
    let dualMonitorMode = false; // Track if dual monitor mode is enabled
    let player1Score = 0; // Individual player scores for dual monitor
    let player2Score = 0;
    
    // Function to send score updates to score display window
    function sendScoreUpdate() {
        if (!dualMonitorMode) return;
        
        try {
            const channel = new BroadcastChannel('joykado-score');
            channel.postMessage({
                type: 'score-update',
                score: score,
                combo: combo,
                player1Score: player1Score,
                player2Score: player2Score
            });
        } catch(e) {
            console.log('Could not send score update:', e);
        }
    }
    
    // Function to send character update
    function sendCharacterUpdate(player, state) {
        if (!dualMonitorMode) return;
        
        try {
            const channel = new BroadcastChannel('joykado-score');
            channel.postMessage({
                type: 'character-update',
                player: player,
                state: state
            });
        } catch(e) {
            console.log('Could not send character update:', e);
        }
    }
    
    // Coolify API Configuration
    // Load from config.js (loaded from backend /config.js endpoint or local config.js)
    // The backend automatically serves the correct URL from COOLIFY_URL environment variable
    let COOLIFY_API_URL = 'http://l4swwc004848c44o44csg4wg.5.78.111.174.sslip.io'; // Fallback default
    
    // Function to get URL from config (may need to wait if script is still loading)
    function getCoolifyUrl() {
        if (typeof window !== 'undefined' && window.JOYKADO_CONFIG && window.JOYKADO_CONFIG.COOLIFY_API_URL) {
            return window.JOYKADO_CONFIG.COOLIFY_API_URL;
        }
        return COOLIFY_API_URL;
    }
    
    // Update URL when config is available
    setTimeout(() => {
        const configUrl = getCoolifyUrl();
        if (configUrl !== COOLIFY_API_URL) {
            COOLIFY_API_URL = configUrl;
            console.log('Coolify API URL loaded from config:', COOLIFY_API_URL);
        }
    }, 100);
    
    let coolifyEnabled = true; // Set to false to disable Coolify uploads (will still download JSON)
    
    // Navigation state
    let currentMenuIndex = 0;
    let currentMenuItems = [];
    let navigationMode = 'menu'; // 'menu', 'game', 'options', 'name-entry'
    let currentCategory = null;
    let allSongs = []; // All loaded songs by category
    const CATEGORIES = ['HipHop', 'Anime', 'JPOP', 'Rock', 'Misc'];
    
    // Leaderboard state
    let currentPlayerName = 'AAAAA'; // Default name (5 letters)
    let nameEntryIndex = 0; // Current letter being edited (0-4)
    let usernameEntryIndex = 0; // For home screen username entry
    const ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    let nameEntryMode = false;
    let usernameEntryMode = false;
    
    // Sound effects for hit feedback - use AudioContext for better compatibility
    let soundBuffers = {};
    let audioContext = null;
    
    // Background music
    let backgroundMusic = null;
    let volumeTestSound = null;
    
    // Initialize audio context when user interacts
    function initAudioContext() {
        if (!audioContext) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        return audioContext;
    }
    
    // Load sound files
    async function loadSound(url, direction) {
        try {
            if (!audioContext || audioContext.state === 'closed') {
                initAudioContext();
            }
            
            const response = await fetch(url);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            
            const arrayBuffer = await response.arrayBuffer();
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            soundBuffers[direction] = audioBuffer;
            console.log(`Loaded sound: ${direction}`);
        } catch (error) {
            console.error(`Failed to load sound ${url}, using fallback:`, error);
            // Fallback to HTML5 Audio
            try {
                const audio = new Audio(url);
                audio.volume = 0.6;
                soundBuffers[direction] = audio;
            } catch (fallbackError) {
                console.error(`Fallback audio also failed for ${direction}:`, fallbackError);
            }
        }
    }
    
    // Function to play hit sound
    async function playHitSound(direction) {
        try {
            // Ensure audio context is initialized and running
            if (!audioContext) {
                initAudioContext();
            }
            
            if (audioContext.state === 'suspended') {
                await audioContext.resume();
            }
            
            const buffer = soundBuffers[direction];
            if (!buffer) {
                console.warn(`Sound buffer not loaded for: ${direction}`);
                return;
            }
            
            // If it's an AudioBuffer (Web Audio API)
            if (buffer instanceof AudioBuffer) {
                const source = audioContext.createBufferSource();
                const gainNode = audioContext.createGain();
                gainNode.gain.value = 0.6;
                source.buffer = buffer;
                source.connect(gainNode);
                gainNode.connect(audioContext.destination);
                source.start(0);
            } else if (buffer instanceof HTMLAudioElement || buffer instanceof Audio) {
                // Fallback to HTML5 Audio
                const clone = buffer.cloneNode();
                clone.volume = 0.6;
                clone.play().catch(e => console.log("Sound play error:", e));
            }
        } catch (error) {
            console.error("Error playing sound:", error);
        }
    }
    
    // Preload all sounds after first user interaction
    function preloadSounds() {
        initAudioContext();
        loadSound('sounds/1.wav', 'up');
        loadSound('sounds/2.wav', 'down');
        loadSound('sounds/3.wav', 'left');
        loadSound('sounds/4.wav', 'right');
        
        // Preload combo and miss sounds
        try {
            comboSound = new Audio('sounds/combo.wav');
            comboSound.volume = 0.7;
            missSound = new Audio('sounds/miss.wav');
            missSound.volume = 0.3; // Quiet miss sound
        } catch(e) {
            console.log("Combo/miss sounds not found:", e);
        }
    }
    
    // Play combo sound
    function playComboSound() {
        if (comboSound) {
            try {
                const clone = comboSound.cloneNode();
                clone.volume = 0.7;
                clone.play().catch(e => console.log("Combo sound error:", e));
            } catch(e) {
                console.log("Combo sound play error:", e);
            }
        }
    }
    
    // Play miss sound (only once per miss streak)
    function playMissSound() {
        if (!hasPlayedMissSound && missSound) {
            hasPlayedMissSound = true;
            try {
                const clone = missSound.cloneNode();
                clone.volume = 0.3; // Quiet
                clone.play().catch(e => console.log("Miss sound error:", e));
            } catch(e) {
                console.log("Miss sound play error:", e);
            }
        }
    }
    
    // Update character image based on state
    function updateCharacterImage(player, state) {
        const characterImg = document.getElementById(`character-img-${player}`);
        const characterDisplay = document.getElementById(`character-${player}`);
        
        if (!characterImg || !characterDisplay) return;
        
        // Remove all state classes
        characterDisplay.classList.remove('miss-shake', 'combo-celebration');
        characterState[player] = state;
        
        switch(state) {
            case 'miss':
                characterImg.src = 'kamimiss.png';
                characterDisplay.classList.add('miss-shake');
                // Return to normal after shake
                setTimeout(() => {
                    if (characterState[player] === 'miss') {
                        characterImg.src = 'kami.png';
                        characterState[player] = 'normal';
                    }
                }, 400);
                break;
            case 'combo':
                characterImg.src = 'kamicombo.png';
                characterDisplay.classList.add('combo-celebration');
                // Return to normal after celebration
                setTimeout(() => {
                    if (characterState[player] === 'combo') {
                        characterImg.src = 'kami.png';
                        characterState[player] = 'normal';
                    }
                }, 500);
                break;
            case 'normal':
            default:
                characterImg.src = 'kami.png';
                break;
        }
    }
    
    // Start combo background flicker
    function startComboFlicker() {
        document.body.classList.add('combo-active');
        
        // Clear existing timeout
        if (comboFlickerTimeout) {
            clearTimeout(comboFlickerTimeout);
        }
        
        // Stop flicker after 1 second of no new combos
        comboFlickerTimeout = setTimeout(() => {
            document.body.classList.remove('combo-active');
        }, 1000);
    }
    
    // Stop combo background flicker
    function stopComboFlicker() {
        if (comboFlickerTimeout) {
            clearTimeout(comboFlickerTimeout);
            comboFlickerTimeout = null;
        }
        document.body.classList.remove('combo-active');
    }
    
    // Song Library (Stored in localStorage for persistence)
    let songLibrary = [];
    
    // Load song library from localStorage on startup
    function loadSongLibrary() {
        const stored = localStorage.getItem('songLibrary');
        if (stored) {
            songLibrary = JSON.parse(stored);
        }
    }
    
    // Save song library to localStorage
    function saveSongLibrary() {
        localStorage.setItem('songLibrary', JSON.stringify(songLibrary));
    } 
    // Note: This commented line is just an example - you don't need it.
    // Songs are loaded from Coolify API or localStorage automatically.

    // Note and Key Maps
    const NOTE_MAP = {
        'up': { symbol: '‚ñ≤', colorClass: 'note-up', stream: 'up' },
        'down': { symbol: '‚ñº', colorClass: 'note-down', stream: 'down' },
        'left': { symbol: '‚óÄ', colorClass: 'note-left', stream: 'left' },
        'right': { symbol: '‚ñ∂', colorClass: 'note-right', stream: 'right' }
    };
    
    const KEY_MAP_1P = {
        'w': 'up', 'arrowup': 'up',
        'd': 'right', 'arrowright': 'right',
        's': 'down', 'arrowdown': 'down',
        'a': 'left', 'arrowleft': 'left'
    };

    const KEY_MAP_2P = {
        'i': 'up', 
        'l': 'right', 
        'k': 'down', 
        'j': 'left'
    };

    // === UTILITIES ===

    // Music volume control
    function updateMusicVolume(value) {
        const volume = value / 100;
        mainAudio.volume = volume;
        if (backgroundMusic) {
            backgroundMusic.volume = volume * 0.3; // Background music at 30% of main volume
        }
        // Store volume preference
        localStorage.setItem('musicVolume', volume);
        
        // Play volume test sound
        playVolumeTestSound();
    }
    
    // Play volume test sound when adjusting volume
    function playVolumeTestSound() {
        try {
            if (!volumeTestSound) {
                volumeTestSound = new Audio('sounds/1.wav');
            }
            const clone = volumeTestSound.cloneNode();
            clone.volume = 0.5;
            clone.play().catch(e => console.log("Volume test sound error:", e));
        } catch(e) {
            console.log("Volume test sound not found:", e);
        }
    }
    
    // Load saved volume preference
    function loadMusicVolume() {
        const savedVolume = localStorage.getItem('musicVolume');
        if (savedVolume !== null) {
            const volume = parseFloat(savedVolume);
            mainAudio.volume = volume;
            document.getElementById('music-volume').value = volume * 100;
        } else {
            mainAudio.volume = 0.5; // Default 50%
            document.getElementById('music-volume').value = 50;
        }
    }

    function formatTime(seconds) {
        const min = Math.floor(seconds / 60);
        const sec = Math.floor(seconds % 60).toString().padStart(2, '0');
        return `${min}:${sec}`;
    }

    // Floating Feedback Animation
    function showFeedback(text, type, player) {
        const lane = document.getElementById(`player-lane-${player}`);
        const feedback = document.createElement('div');
        feedback.className = `score-feedback ${type === 'good' ? 'feedback-good' : 'feedback-miss'}`;
        feedback.innerText = text;
        lane.appendChild(feedback);

        // Position it above the hit zone
        const hitZoneBottom = document.getElementById(`hit-zone-${player}`).offsetTop;
        feedback.style.bottom = `${lane.clientHeight - hitZoneBottom + 20}px`;

        // Clean up after animation
        setTimeout(() => {
            feedback.remove();
        }, 1000);
    }
    
    // Show combo milestone (10x, 20x, etc.)
    function showComboMilestone(comboCount, comboPoints, player) {
        const lane = document.getElementById(`player-lane-${player}`);
        const hitZone = document.getElementById(`hit-zone-${player}`);
        
        // Create combo milestone feedback
        const milestone = document.createElement('div');
        milestone.className = 'score-feedback feedback-combo';
        milestone.innerHTML = `${comboCount}x COMBO!<br><span style="font-size: 0.7em;">+${comboPoints} points</span>`;
        lane.appendChild(milestone);
        
        // Position it above the hit zone
        const hitZoneBottom = hitZone.offsetTop;
        milestone.style.bottom = `${lane.clientHeight - hitZoneBottom + 20}px`;
        milestone.style.textAlign = 'center';
        
        // Clean up after animation
        setTimeout(() => {
            milestone.remove();
        }, 2000);
    }
    
    // Create sparkles animation
    function createSparkles(player) {
        const lane = document.getElementById(`player-lane-${player}`);
        const hitZone = document.getElementById(`hit-zone-${player}`);
        const hitZoneRect = hitZone.getBoundingClientRect();
        const laneRect = lane.getBoundingClientRect();
        
        // Create multiple sparkles
        for (let i = 0; i < 8; i++) {
            const sparkle = document.createElement('div');
            sparkle.className = 'sparkle';
            
            // Random position around hit zone
            const angle = (Math.PI * 2 * i) / 8;
            const distance = 60 + Math.random() * 40;
            const x = hitZoneRect.left - laneRect.left + hitZoneRect.width / 2 + Math.cos(angle) * distance;
            const y = hitZoneRect.top - laneRect.top + hitZoneRect.height / 2 + Math.sin(angle) * distance;
            
            sparkle.style.left = `${x}px`;
            sparkle.style.top = `${y}px`;
            sparkle.style.animationDelay = `${i * 0.05}s`;
            
            lane.appendChild(sparkle);
            
            // Clean up after animation
            setTimeout(() => {
                if (sparkle.parentNode) {
                    sparkle.remove();
                }
            }, 600);
        }
    }

    // === MESSAGE BOX UTILITY ===
    let messageResolve = null;

    function showMessage(content, showCancel = false) {
        document.getElementById('message-content').innerHTML = content;
        const cancelBtn = document.getElementById('message-cancel-btn');
        cancelBtn.style.display = showCancel ? 'inline-block' : 'none';
        
        document.getElementById('custom-message-box').style.display = 'flex';

        return new Promise(resolve => {
            messageResolve = resolve;
        });
    }

    function hideMessage(isCancel = false) {
        document.getElementById('custom-message-box').style.display = 'none';
        if (messageResolve) {
            messageResolve(!isCancel); // Resolve with true for OK, false for Cancel
            messageResolve = null;
        }
    }
    
    /**
     * Waits for the HTMLMediaElement to be ready to play (canplaythrough).
     */
    function loadAudioPromise(audioElement) {
        return new Promise((resolve, reject) => {
            // Already ready
            if (audioElement.readyState >= 3) { 
                resolve();
                return;
            }
            
            // Wait for enough data to play without interruption
            audioElement.addEventListener('canplaythrough', resolve, { once: true });
            
            // Handle error
            audioElement.addEventListener('error', (e) => {
                console.error("Audio element error:", e);
                reject(new Error("Audio load error"));
            }, { once: true });
        });
    }

    // === NAVIGATION & RESET ===
    function showScreen(id) {
        document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
        document.getElementById(id).classList.add('active');
        
        // Show/hide game controls based on screen
        const gameControls = document.getElementById('game-controls');
        // Always hide game controls during gameplay (user requested removal)
        gameControls.classList.add('hidden');
        if (id === 'screen-game') {
            navigationMode = 'game';
            document.removeEventListener('keydown', handleMenuNavigation);
        } else {
            navigationMode = 'menu';
            setupMenuNavigation(id);
        }
    }
    
    // Setup keyboard navigation for menus
    function setupMenuNavigation(screenId) {
        currentMenuIndex = 0;
        currentMenuItems = Array.from(document.querySelectorAll(`#${screenId} .menu-item`));
        
        if (currentMenuItems.length > 0) {
            currentMenuItems[0].classList.add('selected');
            currentMenuItems[0].focus();
        }
        
        document.addEventListener('keydown', handleMenuNavigation);
    }
    
    // Handle menu navigation with keyboard
    function handleMenuNavigation(event) {
        if (navigationMode !== 'menu') return;
        if (appMode === 'player' || appMode === 'editor') return; // Don't interfere with game
        
        // Don't handle navigation if user is typing in an input field
        const activeElement = document.activeElement;
        if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.tagName === 'SELECT')) {
            // Allow normal typing - don't interfere with input fields
            // Only handle Enter for form submission if needed
            return;
        }
        
        const key = event.key.toLowerCase();
        
        // Enter key to select
        if (key === 'enter' || key === ' ') {
            event.preventDefault();
            if (currentMenuItems[currentMenuIndex]) {
                // Play click sound when actually selecting
                playClickSound();
                const action = currentMenuItems[currentMenuIndex].dataset.action;
                handleMenuAction(action);
            }
            return;
        }
        
        // WASD or Arrow keys for navigation
        let moved = false;
        if (key === 'w' || key === 'arrowup') {
            event.preventDefault();
            const oldIndex = currentMenuIndex;
            currentMenuIndex = Math.max(0, currentMenuIndex - 1);
            if (oldIndex !== currentMenuIndex) {
                moved = true;
                playButtonSound(); // Play sound when navigating between items
            }
        } else if (key === 's' || key === 'arrowdown') {
            event.preventDefault();
            const oldIndex = currentMenuIndex;
            currentMenuIndex = Math.min(currentMenuItems.length - 1, currentMenuIndex + 1);
            if (oldIndex !== currentMenuIndex) {
                moved = true;
                playButtonSound(); // Play sound when navigating between items
            }
        } else if (key === 'a' || key === 'arrowleft') {
            event.preventDefault();
            // Volume down in options (when volume item is selected)
            if (appMode === 'options' && currentMenuItems[currentMenuIndex] && currentMenuItems[currentMenuIndex].id === 'volume-menu-item') {
                adjustVolume(-5);
            }
            return;
        } else if (key === 'd' || key === 'arrowright') {
            event.preventDefault();
            // Volume up in options (when volume item is selected)
            if (appMode === 'options' && currentMenuItems[currentMenuIndex] && currentMenuItems[currentMenuIndex].id === 'volume-menu-item') {
                adjustVolume(5);
            }
            return;
        }
        
        if (moved && currentMenuItems.length > 0) {
            currentMenuItems.forEach(item => item.classList.remove('selected'));
            currentMenuItems[currentMenuIndex].classList.add('selected');
            currentMenuItems[currentMenuIndex].focus();
        }
    }
    
    // Handle menu actions
    function handleMenuAction(action) {
        switch(action) {
            case 'play':
                openCategorySelection();
                break;
            case 'scores':
                openLeaderboard();
                break;
            case 'options':
                openOptions();
                break;
            case 'back-to-menu':
                goToMenu();
                break;
            case 'back-to-category':
                // Force refresh when going back to category selection (after upload)
                openCategorySelection(true);
                break;
            case 'open-creator':
                openCreatorSetup();
                break;
            case 'back-to-options':
                openOptions();
                break;
            case 'back-to-joykado':
                // Stop background music
                if (backgroundMusic) {
                    backgroundMusic.pause();
                    backgroundMusic = null;
                }
                window.location.href = 'joykado.html';
                break;
            default:
                if (action.startsWith('category-')) {
                    const category = action.replace('category-', '');
                    selectCategory(category);
                } else if (action.startsWith('song-')) {
                    const songIndex = parseInt(action.replace('song-', ''));
                    selectSongFromList(songIndex);
                }
                // Removed player selection - games now start directly with 1 player
        }
    }
    
    // Volume adjustment in options
    function adjustVolume(delta) {
        const volumeSlider = document.getElementById('music-volume');
        if (!volumeSlider) return;
        
        let currentValue = parseInt(volumeSlider.value) || 50;
        currentValue = Math.max(0, Math.min(100, currentValue + delta));
        volumeSlider.value = currentValue;
        updateMusicVolume(currentValue);
        
        // Update visual bar
        const bar = document.getElementById('options-music-volume-bar');
        const text = document.getElementById('options-volume-text');
        if (bar) bar.style.width = currentValue + '%';
        if (text) text.textContent = currentValue + '%';
    }

    function goToMenu() {
        stopGame();
        appMode = 'menu';
        resetInputs();
        currentCategory = null;
        playNextSound(); // Page change sound
        showScreen('screen-menu');
        
        // Resume background music if it exists
        if (backgroundMusic && backgroundMusic.paused) {
            backgroundMusic.play().catch(e => console.log("Background music play error:", e));
        }
    }
    
    function openCategorySelection(forceRefresh = false) {
        appMode = 'select';
        playClickSound(); // Only play click sound for "Play Songs"
        showScreen('screen-category-select');
        renderCategories();
        
        // Store refresh flag for when category is selected
        if (forceRefresh) {
            window._forceCategoryRefresh = true;
        }
    }
    
    function openOptions() {
        appMode = 'options';
        playNextSound(); // Page change sound
        showScreen('screen-options');
        // Set current volume display
        const volumeSlider = document.getElementById('music-volume');
        if (volumeSlider) {
            const value = parseInt(volumeSlider.value) || 50;
            const bar = document.getElementById('options-music-volume-bar');
            const text = document.getElementById('options-volume-text');
            if (bar) bar.style.width = value + '%';
            if (text) text.textContent = value + '%';
        }
    }
    
    // Render category selection
    function renderCategories() {
        const container = document.getElementById('category-list');
        container.innerHTML = '';
        
        CATEGORIES.forEach((category, index) => {
            const categoryDiv = document.createElement('div');
            categoryDiv.className = 'menu-item beatkami-button bg-white text-gray-700 border-gray-300 text-lg';
            categoryDiv.dataset.action = `category-${category}`;
            categoryDiv.tabIndex = 0;
            categoryDiv.textContent = category;
            container.appendChild(categoryDiv);
        });
        
        setupMenuNavigation('screen-category-select');
    }
    
    // Select category and load songs
    async function selectCategory(category, forceRefresh = false) {
        currentCategory = category;
        
        // Check if we should force refresh (from back button after upload)
        if (window._forceCategoryRefresh) {
            forceRefresh = true;
            window._forceCategoryRefresh = false;
        }
        
        // Show loading message
        const container = document.getElementById('song-list-container');
        if (container) {
            container.innerHTML = '<div class="text-gray-500 py-4">Loading songs from Coolify...</div>';
        }
        
        // Load songs from category (API + localStorage)
        await loadSongsFromCategory(category, forceRefresh);
        
        playNextSound(); // Page change sound
        showScreen('screen-song-select');
        const categoryTitle = document.getElementById('category-title');
        const categorySubtitle = document.getElementById('category-subtitle');
        if (categoryTitle) categoryTitle.textContent = `${category} Songs`;
        if (categorySubtitle) categorySubtitle.textContent = `Select a song to play`;
        renderSongList();
    }
    
    // Play button sound when navigating between menu items (hovering)
    function playButtonSound() {
        try {
            const buttonSound = new Audio('sounds/button.wav');
            buttonSound.volume = 0.5;
            buttonSound.play().catch(e => console.log("Button sound play error:", e));
        } catch(e) {
            console.log("Button sound file not found:", e);
        }
    }
    
    // Play click sound when actually selecting a menu item
    function playClickSound() {
        try {
            const clickSound = new Audio('sounds/click.wav');
            clickSound.volume = 0.5;
            clickSound.play().catch(e => console.log("Click sound play error:", e));
        } catch(e) {
            console.log("Click sound file not found:", e);
        }
    }
    
    // Play next sound when changing pages/screens
    function playNextSound() {
        try {
            // Try to play next.wav, but don't fail if it doesn't exist
            const nextSound = new Audio('sounds/next.wav');
            nextSound.volume = 0.5;
            nextSound.play().catch(e => {
                // Silently fail - file might not exist
                console.log("Next sound not available (this is okay)");
            });
        } catch(e) {
            // Silently fail - file might not exist
            console.log("Next sound file not found (this is okay)");
        }
    }
    
    // Load songs from category folder
    async function loadSongsFromCategory(category, forceRefresh = false) {
        // Clear cache if forcing refresh or if we don't have songs for this category
        if (forceRefresh) {
            allSongs = allSongs.filter(s => s.category !== category);
        }
        
        // If we already have songs for this category and not forcing refresh, skip API call
        const hasSongsForCategory = allSongs.some(s => s.category === category);
        if (hasSongsForCategory && !forceRefresh) {
            console.log(`[loadSongsFromCategory] Using cached songs for ${category}`);
            return;
        }
        
        // Clear songs for this category before loading
        allSongs = allSongs.filter(s => s.category !== category);
        
        // 1. Load from Coolify API first (if enabled)
        if (coolifyEnabled) {
            try {
                const apiUrl = getCoolifyUrl();
                console.log(`Loading songs from Coolify API for category: ${category}`);
                const response = await fetch(`${apiUrl}/api/songs?category=${category}`);
                
                if (response.ok) {
                    const apiSongs = await response.json();
                    console.log(`Loaded ${apiSongs.length} songs from Coolify API`);
                    
                    // Transform API response to match our format
                    for (const apiSong of apiSongs) {
                        try {
                            // Fetch beatmap if URL is provided
                            let beatmap = null;
                            if (apiSong.beatmap_url) {
                                const beatmapResponse = await fetch(`${getCoolifyUrl()}${apiSong.beatmap_url}`);
                                if (beatmapResponse.ok) {
                                    beatmap = await beatmapResponse.json();
                                }
                            }
                            
                            // Parse beatmap correctly
                            let parsedBeatmap = null;
                            if (beatmap) {
                                // If beatmap has a 'notes' property, use that, otherwise use the whole object
                                if (beatmap.notes && Array.isArray(beatmap.notes)) {
                                    parsedBeatmap = beatmap.notes;
                                } else if (Array.isArray(beatmap)) {
                                    parsedBeatmap = beatmap;
                                } else {
                                    console.warn(`Invalid beatmap format for ${apiSong.name}:`, beatmap);
                                    parsedBeatmap = [];
                                }
                            }
                            
                            allSongs.push({
                                name: apiSong.name,
                                mp3Url: `${getCoolifyUrl()}${apiSong.mp3_url}`,
                                beatmap: parsedBeatmap,
                                category: apiSong.category,
                                difficulty: apiSong.difficulty || 'Medium',
                                id: apiSong.id // Store ID for reference
                            });
                        } catch(e) {
                            console.error(`Error loading song ${apiSong.name}:`, e);
                        }
                    }
                } else {
                    console.log(`API request failed: ${response.status}`);
                }
            } catch(e) {
                console.error('Error loading from Coolify API:', e);
            }
        }
        
        // 2. Also check localStorage for locally created songs (not yet uploaded)
        // BUT: Skip songs with blob URLs as they expire and won't work after page reload
        const storedSongs = JSON.parse(localStorage.getItem('songLibrary') || '[]');
        const categorySongs = storedSongs.filter(song => {
            // Only include if it matches category AND doesn't have an expired blob URL
            if (song.category !== category) return false;
            // Skip blob URLs - they expire and won't work after page reload
            if (song.mp3Url && song.mp3Url.startsWith('blob:')) {
                console.warn(`Skipping song "${song.name}" - it has an expired blob URL. Please re-upload it to the server.`);
                return false;
            }
            return true;
        });
        
        // 3. Combine API songs and localStorage songs
        allSongs = [...allSongs, ...categorySongs];
        
        // 4. Remove duplicates by name (prefer API songs over localStorage)
        const uniqueSongs = [];
        const seenNames = new Set();
        // Process in reverse to keep API songs (they come first)
        for (let i = allSongs.length - 1; i >= 0; i--) {
            const song = allSongs[i];
            if (!seenNames.has(song.name)) {
                seenNames.add(song.name);
                uniqueSongs.unshift(song); // Add to beginning to maintain API-first order
            }
        }
        allSongs = uniqueSongs;
        
        // If no songs found, show message
        if (allSongs.length === 0) {
            console.warn(`[loadSongsFromCategory] No songs found for category: ${category}`);
        } else {
            console.log(`[loadSongsFromCategory] Total songs loaded for ${category}: ${allSongs.length}`, allSongs);
        }
    }

    async function askQuit() {
        if (appMode === 'editor' && recordedNotes.length > 0) {
            const shouldSave = await showMessage("You have unsaved beats. Do you want to finish and download your map?", true);
            if (shouldSave) {
                finishEditor();
                return;
            }
        }
        goToMenu();
    }

    function stopGame() {
        mainAudio.pause();
        mainAudio.currentTime = 0;
        cancelAnimationFrame(animationFrameId);
        isPlaying = false;
        document.removeEventListener('keydown', handleKeyDown);
        document.removeEventListener('keyup', handleKeyUp);
        document.removeEventListener('keydown', handleEditorKeyDown); // Ensure editor listener is removed
        
        // Clear falling notes if any
        document.querySelectorAll('.falling-note').forEach(note => note.remove());
        
        // Clear active notes map
        activeNotesMap.clear();
    }

    function resetInputs() {
        // Reset File Inputs (keep mainAudio.src for player persistence until a new file is chosen)
        document.getElementById('file-input-mp3').value = '';
        document.getElementById('file-input-external-mp3').value = '';
        document.getElementById('file-input-map').value = '';
        document.getElementById('mp3-filename').innerText = 'No file selected.';
        document.getElementById('external-upload-status').innerText = '';
        document.getElementById('new-song-name').value = '';
        document.getElementById('song-name-input').style.display = 'none';

        recordedNotes = [];
        playNotes = [];
        notesIndex1P = 0;
        notesIndex2P = 0;
        score = 0;
        combo = 0;
        maxCombo = 0;
        lastComboMilestone = 0;
        playerCount = 0;
        activeNotesMap.clear();
        gameStartTime = 0;
    }

    // === COUNTDOWN LOGIC ===
    async function startCountdown(callback) {
        document.getElementById('countdown-overlay').style.display = 'flex';
        const countdownNumber = document.getElementById('countdown-number');
        
        // Custom CSS for pulse animation (to be added to <style> block for full fix)
        /*
        @keyframes pulse {
            0% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.3); opacity: 1; }
            100% { transform: scale(1); opacity: 0.8; }
        }
        */
        
        for (let i = 3; i >= 1; i--) {
            countdownNumber.innerText = i;
            // Reset pulse animation
            countdownNumber.style.animation = 'none';
            void countdownNumber.offsetWidth; 
            countdownNumber.style.animation = 'pulse 1s ease-out';
            await new Promise(resolve => setTimeout(resolve, 1000));
        }

        countdownNumber.innerText = "GO!";
        await new Promise(resolve => setTimeout(resolve, 500));
        document.getElementById('countdown-overlay').style.display = 'none';
        
        callback();
    }
    
    // === EDITOR MODE LOGIC ===
    function openCreatorSetup() {
        appMode = 'setup';
        activeSong = null; 
        showScreen('screen-setup');
        
        // Reset form
        document.getElementById('file-input-mp3').value = '';
        document.getElementById('mp3-filename').innerText = 'No file selected.';
        document.getElementById('new-song-name').value = '';
        document.getElementById('song-name-input').style.display = 'none';
        document.getElementById('category-select').style.display = 'none';
        document.getElementById('difficulty-select').style.display = 'none';
        document.getElementById('start-editor-btn').style.display = 'none';
        document.getElementById('start-editor-btn').style.visibility = 'hidden';
        currentMp3File = null; // Clear stored file
        originalMp3FileName = null; // Clear original filename
        
        // Ensure listeners are set up
        setupEditorListeners();
        checkEditorReady();
    }

    // Setup file input listener when DOM is ready
    function setupEditorListeners() {
        const fileInput = document.getElementById('file-input-mp3');
        const nameInput = document.getElementById('new-song-name');
        
        if (fileInput) {
            fileInput.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (file) {
                    document.getElementById('mp3-filename').innerText = "Music: " + file.name;
                    const url = URL.createObjectURL(file);
                    mainAudio.src = url;
                    currentMp3File = file; // Store file for later upload
                    originalMp3FileName = file.name; // Store original filename
                    document.getElementById('song-name-input').style.display = 'block';
                    // Play click sound
                    playClickSound();
                } else {
                     document.getElementById('song-name-input').style.display = 'none';
                     mainAudio.src = '';
                     currentMp3File = null;
                     originalMp3FileName = null;
                }
                checkEditorReady();
            });
        }
        
        if (nameInput) {
            nameInput.addEventListener('input', checkEditorReady);
        }
    }

    function checkEditorReady() {
        const mp3Ready = mainAudio.src !== '';
        const nameReady = document.getElementById('new-song-name').value.trim() !== '';
        
        if (mp3Ready && nameReady) {
            document.getElementById('category-select').style.display = 'block';
            document.getElementById('difficulty-select').style.display = 'block';
            const startBtn = document.getElementById('start-editor-btn');
            startBtn.style.display = 'inline-block';
            startBtn.style.visibility = 'visible';
            startBtn.onclick = prepareEditor;
        } else {
             document.getElementById('category-select').style.display = 'none';
             document.getElementById('difficulty-select').style.display = 'none';
             const startBtn = document.getElementById('start-editor-btn');
             startBtn.style.display = 'none';
             startBtn.style.visibility = 'hidden';
        }
    }

    // *** FIX APPLIED HERE ***
    async function prepareEditor() {
        const songName = document.getElementById('new-song-name').value.trim();
        if (!songName) {
            await showMessage("Please enter a name for the song before starting.");
            return;
        }

        if (!mainAudio.src) {
            await showMessage("Please select an audio file first.");
            return;
        }
        
        // 1. Wait for audio to be ready (Can Play)
        try {
            await loadAudioPromise(mainAudio);
        } catch (error) {
            console.error("Audio load failed:", error);
            await showMessage("Failed to load audio file. Please ensure it is a valid format.");
            return;
        }

        const category = document.getElementById('song-category').value;
        const difficulty = document.getElementById('song-difficulty').value;
        
        activeSong = {
            name: songName,
            mp3Url: mainAudio.src,
            beatmap: [],
            category: category,
            difficulty: difficulty
        };
        
        // 2. Start countdown, then start game logic
        startCountdown(startEditorGame);
    }
    
    // *** FIX APPLIED HERE ***
    function startEditorGame() {
        appMode = 'editor';
        showScreen('screen-game');
        document.getElementById('mode-display').innerText = `CREATOR MODE: ${activeSong.name}`;
        document.getElementById('instruction-text').innerText = "Press keys to the beat!";
        document.getElementById('instruction-text').style.display = 'block';
        
        // Stop background music when starting game/editor
        if (backgroundMusic) {
            backgroundMusic.pause();
        }
        
        // Preload sounds on first interaction
        preloadSounds();
        loadMusicVolume();
        
        playerCount = 1;
        document.getElementById('player-lane-2').style.display = 'none';
        
        recordedNotes = [];
        
        // 1. Setup the listener to start the loop *only* when the audio starts playing
        mainAudio.onplaying = () => {
            isPlaying = true;
            animationFrameId = requestAnimationFrame(editorGameLoop);
        };
        
        // 2. Setup the listener for when the song naturally ends
        mainAudio.onended = finishEditor;

        // 3. Play the audio, which triggers the onplaying listener once successful
        mainAudio.play().catch(e => {
             console.error("Audio playback error:", e);
             showMessage("Error: Audio playback failed. The browser might be blocking autoplay. Try reloading and clicking faster.", false);
        });
        
        document.addEventListener('keydown', handleEditorKeyDown);
    }

    function handleEditorKeyDown(event) {
        const key = event.key.toLowerCase();
        let direction = KEY_MAP_1P[key];

        if (direction && !event.repeat) {
            if (!isPlaying) {
                 console.log("Audio not playing yet, key press ignored.");
                 showMessage("The music hasn't started yet! Wait for the countdown to finish.", false);
                 return;
            }
            
            // Only P1 keys are used in creator mode
            recordedNotes.push({
                time: mainAudio.currentTime, // Correctly uses audio time
                direction: direction,
                player: 1 
            });
            
            // Play hit sound
            playHitSound(direction);
            
            // Visual feedback on hit zone
            const hitZone = document.getElementById('hit-zone-1');
            hitZone.classList.add('good');
            hitZone.classList.add(`active-${direction}`);
            setTimeout(() => {
                hitZone.classList.remove('good');
                hitZone.classList.remove(`active-${direction}`);
            }, 100);
        }
    }

    function editorGameLoop(timestamp) {
        if (!lastTime) lastTime = timestamp;
        // const elapsed = timestamp - lastTime;
        lastTime = timestamp;

        if (mainAudio.paused) return; // Audio paused, stop loop

        // Update UI
        const currentTime = mainAudio.currentTime;
        document.getElementById('time-display').innerText = formatTime(currentTime);
        document.getElementById('progress-bar').style.width = `${(currentTime / mainAudio.duration) * 100}%`;

        // If in editor mode, we can optionally show note creation feedback
        
        animationFrameId = requestAnimationFrame(editorGameLoop);
    }


    async function finishEditor() {
        stopGame();
        
        // 1. Add/Update Song in Library
        activeSong.beatmap = recordedNotes;
        
        const existingIndex = songLibrary.findIndex(s => s.name === activeSong.name);
        if (existingIndex > -1) {
            songLibrary[existingIndex] = activeSong;
        } else {
            songLibrary.push(activeSong);
        }
        
        // Save to localStorage
        saveSongLibrary();

        // 2. Prepare beatmap data
        const beatmapData = {
            notes: recordedNotes,
            metadata: {
                name: activeSong.name,
                category: activeSong.category,
                difficulty: activeSong.difficulty
            }
        };
        
        // 3. Upload to Coolify (if enabled)
        let uploadStatus = '';
        let uploadSuccess = false;
        if (coolifyEnabled) {
            try {
                uploadStatus = await uploadToCoolify(activeSong, beatmapData);
                // Check if upload was successful (status contains success message)
                uploadSuccess = uploadStatus.includes('‚úÖ') || uploadStatus.includes('Successfully');
            } catch (error) {
                console.error('Coolify upload error:', error);
                uploadStatus = '<br><span style="color: #bc4749;">‚ö†Ô∏è Upload to Coolify failed. Check console for details.</span>';
                uploadSuccess = false;
            }
        }
        
        // 4. Download Beatmap JSON only if upload failed or Coolify is disabled
        if (!uploadSuccess) {
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(beatmapData));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            // Generate unique filename for download
            const timestamp = Date.now();
            const randomId = Math.random().toString(36).substring(2, 9);
            downloadAnchorNode.setAttribute("download", `${activeSong.name.replace(/\s/g, '_')}_${timestamp}_${randomId}_beatmap.json`);
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        }
        
        // 5. Clear cached songs for this category so it refreshes next time
        if (uploadSuccess && activeSong.category) {
            // Force reload next time category is selected
            allSongs = allSongs.filter(s => s.category !== activeSong.category || s.name !== activeSong.name);
        }
        
        // 6. Show Result Screen
        document.getElementById('result-title').innerText = "Beatmap Creation Complete!";
        const resultMessage = uploadSuccess 
            ? `Your map for <b>${activeSong.name}</b> (${recordedNotes.length} notes) has been saved to the Song Library and uploaded to Coolify!${uploadStatus}`
            : `Your map for <b>${activeSong.name}</b> (${recordedNotes.length} notes) has been saved to the Song Library.${uploadStatus ? uploadStatus : '<br><span style="color: #bc4749;">JSON file downloaded as backup.</span>'}`;
        document.getElementById('result-message').innerHTML = resultMessage;
        
        appMode = 'results';
        showScreen('screen-result');
        // Setup navigation after a brief delay to ensure DOM is ready
        setTimeout(() => {
            setupMenuNavigation('screen-result');
        }, 100);
    }
    
    // Upload song and beatmap to Coolify
    async function uploadToCoolify(song, beatmapData) {
        try {
            let mp3File;
            
            // CRITICAL: Always use the stored file - it's the original File object
            if (!currentMp3File) {
                throw new Error('MP3 file not found. Please ensure you selected an MP3 file before creating the beatmap.');
            }
            
            mp3File = currentMp3File;
            console.log('üì§ Uploading MP3 file:', {
                name: mp3File.name,
                size: mp3File.size,
                type: mp3File.type,
                lastModified: mp3File.lastModified
            });
            
            if (!mp3File || mp3File.size === 0) {
                throw new Error('MP3 file is empty or invalid');
            }
            
            // Create FormData for multipart upload
            const formData = new FormData();
            
            // CRITICAL: Append MP3 file first with proper field name
            formData.append('mp3', mp3File, mp3File.name);
            
            // Append beatmap as JSON string (not as file)
            formData.append('beatmap', JSON.stringify(beatmapData));
            
            // Append metadata
            formData.append('name', song.name);
            formData.append('category', song.category);
            formData.append('difficulty', song.difficulty || 'Medium');
            
            // Append original filename for better naming
            if (originalMp3FileName) {
                formData.append('original_filename', originalMp3FileName);
            }
            
            // Debug: Log FormData contents (can't directly read, but verify what we're sending)
            console.log('üì¶ FormData prepared:', {
                name: song.name,
                category: song.category,
                difficulty: song.difficulty,
                mp3FileName: mp3File.name,
                mp3FileSize: mp3File.size,
                beatmapSize: JSON.stringify(beatmapData).length
            });
            
            const apiUrl = getCoolifyUrl();
            console.log('üåê Uploading to:', `${apiUrl}/api/songs/upload`);
            
            // Upload to Coolify API
            const response = await fetch(`${apiUrl}/api/songs/upload`, {
                method: 'POST',
                body: formData
                // Don't set Content-Type - browser will set it with boundary for multipart/form-data
            });
            
            if (!response.ok) {
                const errorText = await response.text();
                console.error('‚ùå Upload failed:', response.status, errorText);
                throw new Error(`Upload failed: ${response.status} - ${errorText}`);
            }
            
            const result = await response.json();
            console.log('‚úÖ Upload successful:', result);
            
            // Clear the stored file after successful upload
            currentMp3File = null;
            originalMp3FileName = null;
            
            return `<br><span style="color: #6a994e;">‚úÖ Successfully uploaded to Coolify in category: <b>${song.category}</b></span>`;
        } catch (error) {
            console.error('‚ùå Upload error:', error);
            // Return error message but don't throw - allow download to continue
            if (error.message.includes('Failed to fetch')) {
                return `<br><span style="color: #bc4749;">‚ö†Ô∏è Upload failed: Cannot reach Coolify server. Check that COOLIFY_API_URL is correct and the server is running.</span>`;
            }
            return `<br><span style="color: #bc4749;">‚ö†Ô∏è Upload failed: ${error.message}</span>`;
        }
    }
    
    // === PLAYER MODE SETUP: SONG SELECTION/UPLOAD ===
    
    let externalMp3Url = null;
    let externalMp3Name = null;
    let externalMapData = null;
    
    function openSongSelection() {
        appMode = 'select';
        showScreen('screen-song-select');
        renderSongList();
        
        // Clear external upload status
        externalMp3Url = null;
        externalMapData = null;
        document.getElementById('external-upload-status').innerText = '';
    }

    async function handleExternalMp3Upload(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        externalMp3Name = file.name.replace(/\.[^/.]+$/, "");
        externalMp3Url = URL.createObjectURL(file);
        
        document.getElementById('external-upload-status').innerHTML = `MP3: <b>${file.name}</b> loaded. Upload map file or choose a local song.`;
        checkExternalReady();
    }

    async function handleExternalMapUpload(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = async (ev) => {
            try {
                const parsed = JSON.parse(ev.target.result);
                // Handle both old format (array) and new format (with metadata)
                if (Array.isArray(parsed)) {
                    externalMapData = parsed;
                } else if (parsed.notes && Array.isArray(parsed.notes)) {
                    externalMapData = parsed.notes;
                    // Store metadata if available
                    if (parsed.metadata) {
                        externalMapMetadata = parsed.metadata;
                    }
                } else {
                    throw new Error("Invalid format");
                }
                document.getElementById('external-upload-status').innerHTML = `Map: <b>${file.name}</b> loaded. Ready to start!`;
                checkExternalReady();
            } catch(err) {
                await showMessage("Invalid map file format. Please ensure it's a valid JSON array.");
                externalMapData = null;
            }
        };
        reader.readAsText(file);
    }
    
    let externalMapMetadata = null;

    function checkExternalReady() {
        if (externalMp3Url && externalMapData) {
            // Found both, create temporary active song and go to player setup
            activeSong = {
                name: externalMp3Name || externalMapMetadata?.name || 'External Song',
                mp3Url: externalMp3Url,
                beatmap: externalMapData.sort((a, b) => a.time - b.time), // Ensure sorted
                category: externalMapMetadata?.category || 'Misc',
                difficulty: externalMapMetadata?.difficulty || 'Medium'
            };
            // Start game directly (1 player)
            playerCount = 1;
            preparePlayerGame(1).catch(error => {
                console.error('Failed to prepare game:', error);
                alert('Failed to load song: ' + error.message);
            });
        }
    }
    
    document.getElementById('file-input-external-mp3').addEventListener('change', handleExternalMp3Upload);
    document.getElementById('file-input-map').addEventListener('change', handleExternalMapUpload);


    function renderSongList() {
        const container = document.getElementById('song-list-container');
        container.innerHTML = '';

        const songsToShow = currentCategory ? allSongs : songLibrary;
        
        console.log(`[renderSongList] Rendering songs. currentCategory: ${currentCategory}, songsToShow.length: ${songsToShow.length}`);
        console.log(`[renderSongList] allSongs:`, allSongs);
        console.log(`[renderSongList] songLibrary:`, songLibrary);
        
        if (songsToShow.length === 0) {
            const noSongsMsg = document.getElementById('no-songs-message');
            if (noSongsMsg) {
                noSongsMsg.textContent = currentCategory 
                    ? `No songs found in ${currentCategory} category.` 
                    : 'No songs created yet. Use the "Beatmap Creator" in Options!';
                noSongsMsg.style.display = 'block';
            }
            return;
        }
        const noSongsMsg = document.getElementById('no-songs-message');
        if (noSongsMsg) {
            noSongsMsg.style.display = 'none';
        }

        songsToShow.forEach((song, index) => {
            const card = document.createElement('div');
            card.className = 'menu-item song-card flex justify-between items-center p-4 bg-white rounded-xl shadow-md hover:shadow-lg border border-gray-200';
            card.dataset.action = `song-${index}`;
            card.tabIndex = 0;
            
            const difficulty = song.difficulty || 'Medium';
            const difficultyColor = {
                'Easy': 'text-green-600',
                'Medium': 'text-yellow-600',
                'Hard': 'text-red-600'
            }[difficulty] || 'text-gray-600';

            const detailsHtml = `
                <div class="text-left flex-1">
                    <div class="font-bold text-lg text-gray-800">${song.name}</div>
                    <div class="text-sm text-gray-500">${song.beatmap ? song.beatmap.length : 0} notes</div>
                    <div class="text-xs ${difficultyColor} font-semibold mt-1">${difficulty}</div>
                </div>
                <div class="text-xl text-beatkami-primary">‚ñ∂</div>
            `;
            card.innerHTML = detailsHtml;
            // Make clickable with Enter key (already handled by menu navigation)
            // Also add click handler for mouse users
            card.addEventListener('click', () => {
                playClickSound();
                selectSongFromList(index);
            });
            container.appendChild(card);
        });
        
        setupMenuNavigation('screen-song-select');
    }
    
    function selectSongFromList(index) {
        const songsToShow = currentCategory ? allSongs : songLibrary;
        if (songsToShow[index]) {
            selectSong(songsToShow[index]);
        }
    }

    function selectSong(song) {
        activeSong = song;
        // Check if username is already saved
        const savedUsername = localStorage.getItem('joykado_username');
        if (savedUsername) {
            // Use saved username, skip name entry
            currentPlayerName = savedUsername;
            // Skip player setup, go directly to game (default to 1 player)
            playerCount = 1;
            preparePlayerGame(1).catch(error => {
                console.error('Failed to prepare game:', error);
                alert('Failed to load song. Please check the console for details.');
            });
        } else {
            // No saved username, show name entry
            openNameEntry();
        }
    }
    
    // === NAME ENTRY SCREEN ===
    function openNameEntry() {
        appMode = 'name-entry';
        nameEntryMode = true;
        nameEntryIndex = 0;
        // Try to load saved username, otherwise use default
        const savedUsername = localStorage.getItem('joykado_username');
        currentPlayerName = savedUsername || 'AAAAA';
        updateNameDisplay();
        showScreen('screen-name-entry');
        document.addEventListener('keydown', handleNameEntryKeyDown);
    }
    
    function handleNameEntryKeyDown(event) {
        if (!nameEntryMode) return;
        
        const key = event.key.toLowerCase();
        event.preventDefault();
        
        if (key === 'enter' || key === ' ') {
            // Confirm name
            nameEntryMode = false;
            document.removeEventListener('keydown', handleNameEntryKeyDown);
            playClickSound();
            // Save username to localStorage
            localStorage.setItem('joykado_username', currentPlayerName);
            // Skip player setup, go directly to game (default to 1 player)
            playerCount = 1;
            preparePlayerGame(1).catch(error => {
                console.error('Failed to prepare game:', error);
                alert('Failed to load song: ' + error.message);
            });
            return;
        }
        
        if (key === 'a' || key === 'arrowleft') {
            // Move to previous position (left)
            nameEntryIndex = Math.max(0, nameEntryIndex - 1);
            updateNameDisplay();
            playButtonSound();
        } else if (key === 'd' || key === 'arrowright') {
            // Move to next position (right)
            nameEntryIndex = Math.min(4, nameEntryIndex + 1);
            updateNameDisplay();
            playButtonSound();
        } else if (key === 'w' || key === 'arrowup') {
            // Previous letter (up in alphabet)
            const currentLetter = currentPlayerName[nameEntryIndex];
            const currentIndex = ALPHABET.indexOf(currentLetter);
            const newIndex = (currentIndex - 1 + ALPHABET.length) % ALPHABET.length;
            updateNameLetter(nameEntryIndex, ALPHABET[newIndex]);
            playButtonSound();
        } else if (key === 's' || key === 'arrowdown') {
            // Next letter (down in alphabet)
            const currentLetter = currentPlayerName[nameEntryIndex];
            const currentIndex = ALPHABET.indexOf(currentLetter);
            const newIndex = (currentIndex + 1) % ALPHABET.length;
            updateNameLetter(nameEntryIndex, ALPHABET[newIndex]);
            playButtonSound();
        }
    }
    
    function updateNameLetter(index, letter) {
        const nameArray = currentPlayerName.split('');
        nameArray[index] = letter;
        currentPlayerName = nameArray.join('');
        updateNameDisplay();
    }
    
    function updateNameDisplay() {
        const display = document.getElementById('name-display');
        const indexDisplay = document.getElementById('current-letter-index');
        
        if (display) {
            let html = '';
            for (let i = 0; i < 5; i++) {
                const letter = currentPlayerName[i] || 'A';
                const isActive = i === nameEntryIndex;
                const style = isActive 
                    ? 'color: var(--beatkami-primary); text-shadow: 0 0 20px var(--beatkami-primary); transform: scale(1.2);'
                    : 'color: var(--hunter-green);';
                html += `<span style="${style}">${letter}</span>`;
            }
            display.innerHTML = html;
        }
        
        if (indexDisplay) {
            indexDisplay.textContent = nameEntryIndex + 1;
        }
    }
    
    // === LEADERBOARD ===
    function openLeaderboard() {
        appMode = 'leaderboard';
        showScreen('screen-leaderboard');
        loadLeaderboard();
        setupMenuNavigation('screen-leaderboard');
    }
    
    async function loadLeaderboard(filter = 'all') {
        const container = document.getElementById('leaderboard-list');
        container.innerHTML = '<div class="text-gray-500 py-4">Loading leaderboard...</div>';
        
        try {
            const apiUrl = getCoolifyUrl();
            let url = `${apiUrl}/api/leaderboard?limit=50`;
            if (filter !== 'all') {
                url += `&song_category=${filter}`;
            }
            
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            
            const scores = await response.json();
            
            if (scores.length === 0) {
                container.innerHTML = '<div class="text-gray-500 py-4">No scores yet. Be the first!</div>';
                return;
            }
            
            container.innerHTML = '';
            
            // Group by song
            const bySong = {};
            scores.forEach(score => {
                const key = `${score.song_name} (${score.song_category})`;
                if (!bySong[key]) {
                    bySong[key] = [];
                }
                bySong[key].push(score);
            });
            
            // Display top 10 per song
            Object.keys(bySong).sort().forEach(songKey => {
                const songScores = bySong[songKey].slice(0, 10);
                
                const songHeader = document.createElement('div');
                songHeader.className = 'text-left font-bold text-lg text-gray-700 mb-2 mt-4';
                songHeader.textContent = songKey;
                container.appendChild(songHeader);
                
                songScores.forEach((score, idx) => {
                    const row = document.createElement('div');
                    row.className = 'flex justify-between items-center p-3 bg-white rounded-lg border border-gray-200 mb-1';
                    row.innerHTML = `
                        <div class="flex items-center gap-3">
                            <span class="font-bold text-gray-600 w-8">#${idx + 1}</span>
                            <span class="font-bold text-gray-800">${score.player_name}</span>
                        </div>
                        <div class="flex items-center gap-4">
                            <span class="text-gray-600">Combo: <strong>${score.combo}</strong></span>
                            <span class="text-gray-600">Accuracy: <strong>${(score.accuracy || 0).toFixed(1)}%</strong></span>
                            <span class="font-bold text-xl text-beatkami-primary">${score.score.toLocaleString()}</span>
                        </div>
                    `;
                    container.appendChild(row);
                });
            });
        } catch(e) {
            console.error('Error loading leaderboard:', e);
            container.innerHTML = '<div class="text-red-500 py-4">Failed to load leaderboard. Check console for details.</div>';
        }
    }
    
    async function saveScore(score, combo, accuracy) {
        if (!activeSong || !currentPlayerName) return;
        
        try {
            const apiUrl = getCoolifyUrl();
            const response = await fetch(`${apiUrl}/api/leaderboard`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    player_name: currentPlayerName,
                    song_name: activeSong.name,
                    song_category: activeSong.category || 'Misc',
                    score: score,
                    combo: combo,
                    accuracy: accuracy
                })
            });
            
            if (response.ok) {
                console.log('Score saved successfully');
            } else {
                console.error('Failed to save score:', await response.text());
            }
        } catch(e) {
            console.error('Error saving score:', e);
        }
    }

    // === PLAYER MODE SETUP: PLAYER COUNT ===
    function openPlayerSetup() {
        appMode = 'player_setup';
        showScreen('screen-player-setup');
        const title = activeSong.name + (activeSong.difficulty ? ` (${activeSong.difficulty})` : '');
        document.getElementById('player-setup-song-title').innerText = title;
        playerCount = 0; // Reset player count
        document.getElementById('player-count-display').innerText = 'Use WASD to select, Enter to confirm.';
        document.getElementById('start-player-btn').style.display = 'none';
        
        // Setup keyboard navigation for player count selection
        setupMenuNavigation('screen-player-setup');
    }

    function setPlayerCount(count) {
        playerCount = count;
        document.getElementById('player-count-display').innerText = `${count} Player${count > 1 ? 's' : ''} selected. Press Enter to start.`;
        document.getElementById('start-player-btn').style.display = 'inline-block';
        document.getElementById('start-player-btn').onclick = () => preparePlayerGame(count);
        
        // Make start button selectable
        const startBtn = document.getElementById('start-player-btn');
        startBtn.className = 'menu-item beatkami-button bg-green-50 text-green-700 border-green-300 font-bold';
        startBtn.dataset.action = 'start-game';
        startBtn.tabIndex = 0;
        setupMenuNavigation('screen-player-setup');
    }
    
    async function preparePlayerGame(count) {
        // Ensure audio context is initialized before loading
        if (!audioContext) {
            initAudioContext();
        }
        
        // Validate song data
        if (!activeSong || !activeSong.mp3Url) {
            throw new Error('Song data is missing or invalid');
        }
        
        // Load the audio file
        console.log('Loading audio from:', activeSong.mp3Url);
        mainAudio.src = activeSong.mp3Url;
        
        // Check if this is a blob URL (from localStorage) - these expire and won't work
        if (activeSong.mp3Url && activeSong.mp3Url.startsWith('blob:')) {
            throw new Error('This song was saved locally and the file is no longer available. Please re-upload it or use a song from the server.');
        }
        
        // Wait for audio to be ready
        try {
            await new Promise((resolve, reject) => {
                // Check if audio is already loaded
                if (mainAudio.readyState >= 2) {
                    resolve();
                    return;
                }
                
                const timeout = setTimeout(() => {
                    reject(new Error('Audio load timeout - the file may not exist or the server is not responding'));
                }, 10000); // Increased timeout to 10 seconds
                
                const cleanup = () => {
                    clearTimeout(timeout);
                    mainAudio.removeEventListener('loadeddata', onLoaded);
                    mainAudio.removeEventListener('error', onError);
                };
                
                const onLoaded = () => {
                    cleanup();
                    resolve();
                };
                
                const onError = (error) => {
                    cleanup();
                    const errorMsg = error?.message || mainAudio.error?.message || 'Unknown audio error';
                    const errorCode = mainAudio.error?.code;
                    let detailedError = `Audio load failed: ${errorMsg}`;
                    if (errorCode) {
                        detailedError += ` (Error code: ${errorCode})`;
                    }
                    reject(new Error(detailedError));
                };
                
                mainAudio.addEventListener('loadeddata', onLoaded);
                mainAudio.addEventListener('error', onError);
            });
        } catch (error) {
            console.error('Failed to load audio:', error);
            const errorMessage = error?.message || 'Unknown error';
            throw new Error(`Failed to load song: ${errorMessage}`);
        }
        
        // Parse beatmap - handle different formats
        let beatmapData = activeSong.beatmap;
        if (Array.isArray(beatmapData)) {
            // Already an array of notes
            playNotes = beatmapData.slice().sort((a, b) => a.time - b.time);
        } else if (beatmapData && beatmapData.notes) {
            // Beatmap object with notes property
            playNotes = beatmapData.notes.slice().sort((a, b) => a.time - b.time);
        } else if (beatmapData && Array.isArray(beatmapData)) {
            playNotes = beatmapData.slice().sort((a, b) => a.time - b.time);
        } else {
            console.error('Invalid beatmap format:', beatmapData);
            playNotes = [];
        }
        
        console.log(`Loaded ${playNotes.length} notes for game`);
        
        startCountdown(() => startPlayerGame(count));
    }

    // === PLAYER MODE GAME LOGIC ===
    function startPlayerGame(count) {
        appMode = 'player';
        showScreen('screen-game');
        document.getElementById('mode-display').innerText = `PLAYING: ${activeSong.name}`;
        document.getElementById('instruction-text').innerText = "Hit the notes when they reach the target!";
        document.getElementById('instruction-text').style.display = 'block';
        
        // Update instruction for 2-player mode
        if (playerCount === 2) {
            document.getElementById('instruction-text').innerText = "Hit the notes when they reach the target! (2 Players)";
        }
        
        // Stop background music when starting game/editor
        if (backgroundMusic) {
            backgroundMusic.pause();
        }
        
        // Preload sounds on first interaction
        preloadSounds();
        loadMusicVolume();
        
        // Reset/Setup game state
        notesIndex1P = 0;
        notesIndex2P = 0;
        score = 0;
        combo = 0;
        maxCombo = 0;
        lastComboMilestone = 0;
        player1Score = 0;
        player2Score = 0;
        hasPlayedMissSound = false; // Reset miss sound flag
        characterState = { 1: 'normal', 2: 'normal' }; // Reset character states
        stopComboFlicker(); // Stop any active flicker
        activeNotesMap.clear(); // Clear active notes
        document.getElementById('score-display').innerText = 'SCORE: 0';
        document.getElementById('combo-display').innerText = 'COMBO: 0';
        
        // Hide score/combo displays if in dual monitor mode
        if (dualMonitorMode) {
            document.getElementById('score-display').style.display = 'none';
            document.getElementById('combo-display').style.display = 'none';
        } else {
            document.getElementById('score-display').style.display = 'block';
            document.getElementById('combo-display').style.display = 'block';
        }
        
        // Reset character images to normal
        updateCharacterImage(1, 'normal');
        if (playerCount === 2) {
            updateCharacterImage(2, 'normal');
        }
        
        // Try to connect to score window if dual monitor mode is enabled
        if (dualMonitorMode) {
            // Look for the score window - it should be opened from joykado.html
            // We'll use a BroadcastChannel or try to find it via localStorage
            setTimeout(() => {
                // Try to find score window by checking all windows
                // For now, we'll use a different approach - the score window will listen for messages
                // Send game start message via BroadcastChannel
                try {
                    const channel = new BroadcastChannel('joykado-score');
                    channel.postMessage({
                        type: 'game-start',
                        playerCount: count
                    });
                } catch(e) {
                    console.log('BroadcastChannel not available:', e);
                }
            }, 500);
        }
        
        // Reset all notes to not hit
        playNotes.forEach(note => {
            note.hit = false;
        });
        
        // Set game start time after a brief delay to allow notes to spawn
        gameStartTime = -1.0; // Start checking after 1 second

        // Setup lanes
        const lane2 = document.getElementById('player-lane-2');
        if (count === 2) {
            lane2.style.display = 'flex';
        } else {
            lane2.style.display = 'none';
        }

        // Start playing
        mainAudio.play().then(() => {
            // Set game start time when audio actually starts
            gameStartTime = mainAudio.currentTime;
        });
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);
        mainAudio.onended = finishPlayerGame;
        
        // Fallback: set start time to current audio time
        gameStartTime = 0;
        
        animationFrameId = requestAnimationFrame(playerGameLoop);
    }

    function handleKeyDown(event) {
        const key = event.key.toLowerCase();
        let direction, player, hitZone;

        if (KEY_MAP_1P[key]) {
            direction = KEY_MAP_1P[key];
            player = 1;
            hitZone = document.getElementById('hit-zone-1');
        } else if (playerCount === 2 && KEY_MAP_2P[key]) {
            direction = KEY_MAP_2P[key];
            player = 2;
            hitZone = document.getElementById('hit-zone-2');
        } else {
            return;
        }

        if (!event.repeat) {
            // Apply visual active state
            hitZone.classList.add(`active-${direction}`);

            // Perform hit check
            checkHit(direction, player);
        }
    }
    
    function handleKeyUp(event) {
        const key = event.key.toLowerCase();
        let direction, player, hitZone;

        if (KEY_MAP_1P[key]) {
            direction = KEY_MAP_1P[key];
            player = 1;
            hitZone = document.getElementById('hit-zone-1');
        } else if (playerCount === 2 && KEY_MAP_2P[key]) {
            direction = KEY_MAP_2P[key];
            player = 2;
            hitZone = document.getElementById('hit-zone-2');
        } else {
            return;
        }

        // Remove visual active state
        hitZone.classList.remove(`active-${direction}`);
    }

    function checkHit(direction, player) {
        const currentTime = mainAudio.currentTime;
        let bestNote = null;
        let bestTimeDiff = Infinity;
        let foundNoteInWindow = false;

        // Check all active notes for this player
        for (let [noteIndex, noteInfo] of activeNotesMap.entries()) {
            const note = noteInfo.noteData;
            
            // Only check notes for this player
            if (noteInfo.player !== player) {
                continue;
            }
            
            // Skip already hit notes
            if (note.hit) {
                continue;
            }
            
            // Check if note is within hit window
            const timeDiff = Math.abs(note.time - currentTime);
            
            if (timeDiff <= HIT_WINDOW) {
                foundNoteInWindow = true;
                
                // If direction matches, this is a potential hit
                if (note.direction === direction) {
                    // Find the closest matching note in the window
                    if (timeDiff < bestTimeDiff) {
                        bestTimeDiff = timeDiff;
                        bestNote = { noteIndex, noteInfo, note };
                    }
                }
            }
        }
        
        // If we found a matching note, it's a HIT!
        if (bestNote) {
            const { noteIndex, noteInfo, note } = bestNote;
            
            // Mark as hit
            note.hit = true;
            
            // Remove from active notes map
            activeNotesMap.delete(noteIndex);
            
            // Play hit sound
            playHitSound(direction);
            
            combo++;
            const comboPoints = combo * 10;
            score += 100 + comboPoints;
            maxCombo = Math.max(maxCombo, combo);
            
            // Reset miss sound flag when combo increases
            hasPlayedMissSound = false;
            
            // Update character to combo state
            updateCharacterImage(player, 'combo');
            sendCharacterUpdate(player, 'combo');
            
            // Start background flicker on combo
            if (combo > 0) {
                startComboFlicker();
                playComboSound();
            }
            
            // Show combo milestone at 10, 20, 30, etc.
            if (combo >= 10 && combo % 10 === 0 && combo > lastComboMilestone) {
                lastComboMilestone = combo;
                showComboMilestone(combo, comboPoints, player);
                
                // Add sparkles for milestone combos above 25
                if (combo >= 25) {
                    createSparkles(player);
                }
            } else {
                showFeedback("GOOD!", 'good', player);
            }
            
            // Update individual player scores
            if (player === 1) {
                player1Score += 100 + comboPoints;
            } else if (player === 2) {
                player2Score += 100 + comboPoints;
            }
            
            document.getElementById('score-display').innerText = 'SCORE: ' + score;
            const comboDisplay = document.getElementById('combo-display');
            comboDisplay.innerText = 'COMBO: ' + combo;
            
            // Send update to score window if dual monitor mode
            sendScoreUpdate();
            
            // Add visual combo effect
            if (combo > 0) {
                comboDisplay.style.transform = 'scale(1.15)';
                comboDisplay.style.color = 'var(--beatkami-success)';
                comboDisplay.style.textShadow = '0 0 10px var(--beatkami-success)';
                setTimeout(() => {
                    comboDisplay.style.transform = 'scale(1)';
                    comboDisplay.style.color = '';
                    comboDisplay.style.textShadow = '';
                }, 200);
            }

            // Remove the note element from the DOM
            if (noteInfo.element && noteInfo.element.parentNode) {
                noteInfo.element.remove();
            }
            
            // Visual feedback
            const hitZone = document.getElementById(`hit-zone-${player}`);
            hitZone.classList.add('good');
            setTimeout(() => hitZone.classList.remove('good'), 100);
            
            return; // Successfully hit, exit
        }
        
        // Only show MISS if there was a note in the window but wrong direction
        // Also check if enough time has passed since game start (prevent initial false misses)
        const timeSinceStart = mainAudio.currentTime - gameStartTime;
        if (foundNoteInWindow && timeSinceStart > 1.0) {
            // Wrong direction pressed (only after 1 second of gameplay)
            combo = 0;
            lastComboMilestone = 0;
            document.getElementById('combo-display').innerText = 'COMBO: 0';
            sendScoreUpdate();
            
            // Stop combo flicker
            stopComboFlicker();
            
            // Update character to miss state
            updateCharacterImage(player, 'miss');
            sendCharacterUpdate(player, 'miss');
            
            // Play miss sound (only once per miss streak)
            playMissSound();
            
            const hitZone = document.getElementById(`hit-zone-${player}`);
            hitZone.classList.add('miss');
            setTimeout(() => hitZone.classList.remove('miss'), 200);
        }
        // If foundNoteInWindow is false, do nothing - player pressed key but no note in window
    }
    
    function spawnNote(noteData, index) {
        const { time, direction, player } = noteData;
        
        // Skip if already hit (shouldn't happen, but safety check)
        if (noteData.hit) {
            return;
        }
        
        const lane = document.getElementById(`player-lane-${player}`);
        const hitZone = document.getElementById(`hit-zone-${player}`);
        
        const noteElement = document.createElement('div');
        noteElement.id = `note-${index}`;
        noteElement.className = `absolute falling-note ${NOTE_MAP[direction].colorClass}`;
        noteElement.innerText = NOTE_MAP[direction].symbol;
        
        // Calculate lane position (center of the lane)
        noteElement.style.left = '50%';
        
        // Set up transition
        noteElement.style.transition = 'top ' + NOTE_SPEED + 's linear';

        // The note starts at the top and its transition targets the hit zone's center Y position
        const hitZoneY = hitZone.offsetTop + hitZone.offsetHeight / 2;
        const noteHeight = noteElement.offsetHeight || 45; // Default size if not rendered yet
        
        // The final 'top' position to center the note on the hit zone
        const finalTop = hitZoneY - noteHeight / 2;

        // Apply starting position (top of the lane)
        noteElement.style.top = '-60px'; // Start off-screen
        
        lane.appendChild(noteElement);
        
        // Force reflow to ensure CSS transition starts from the initial position
        void noteElement.offsetWidth;

        // Now, set the target position to start the animation
        noteElement.style.top = `${finalTop}px`;
        
        // Store the target Y for miss checking
        noteElement.dataset.hitTime = time;
        noteElement.dataset.noteIndex = index;
        
        // Add to active notes map
        activeNotesMap.set(index, {
            element: noteElement,
            noteData: noteData,
            player: player
        });
    }

    function playerGameLoop(timestamp) {
        if (!lastTime) lastTime = timestamp;
        // const elapsed = timestamp - lastTime;
        lastTime = timestamp;

        if (mainAudio.paused || !mainAudio.src) {
            cancelAnimationFrame(animationFrameId);
            return;
        }

        const currentTime = mainAudio.currentTime;
        if (document.getElementById('time-display')) {
            document.getElementById('time-display').innerText = formatTime(currentTime);
        }
        if (document.getElementById('progress-bar')) {
            document.getElementById('progress-bar').style.width = `${(currentTime / mainAudio.duration) * 100}%`;
        }

        // Ensure we have notes to spawn
        if (!playNotes || playNotes.length === 0) {
            animationFrameId = requestAnimationFrame(playerGameLoop);
            return;
        }

        // 1. Check for notes that should be spawned
        // Spawn all notes that should be visible (for both players in sequence)
        for (let i = 0; i < playNotes.length; i++) {
            const note = playNotes[i];
            
            // Validate note structure
            if (!note || typeof note.time !== 'number' || !note.direction || !note.player) {
                console.warn(`Invalid note at index ${i}:`, note);
                continue;
            }
            
            // Skip if already spawned or hit
            if (activeNotesMap.has(i) || note.hit) {
                continue;
            }
            
            // Skip if note is too far in the future
            if (note.time > currentTime + SPAWN_OFFSET_TIME) {
                continue;
            }
            
            // Spawn the note if it's time
            if (note.time <= currentTime + SPAWN_OFFSET_TIME) {
                spawnNote(note, i);
            }
        }
        
        // 2. Check for notes that were missed (passed the hit window without being hit)
        for (let [noteIndex, noteInfo] of activeNotesMap.entries()) {
            const note = noteInfo.noteData;
            
            // Skip if already hit
            if (note.hit) {
                continue;
            }
            
            // If the note's hit time is before the current time minus the hit window, it's a miss
            // Only check for misses after the game has been running for at least 1.5 seconds
            // This prevents false misses at the very start
            const timeSinceStart = currentTime - gameStartTime;
            if (note.time < currentTime - HIT_WINDOW && currentTime > 1.5) {
                // MISSED!
                note.hit = true; // Mark as hit so it doesn't get checked again
                
                combo = 0;
                lastComboMilestone = 0;
                document.getElementById('combo-display').innerText = 'COMBO: 0';
            sendScoreUpdate();
                
                // Stop combo flicker
                stopComboFlicker();
                
                // Update character to miss state
                updateCharacterImage(noteInfo.player, 'miss');
                sendCharacterUpdate(noteInfo.player, 'miss');
                
                // Play miss sound (only once per miss streak)
                playMissSound();
                
                showFeedback("MISS", 'miss', noteInfo.player);
                const hitZone = document.getElementById(`hit-zone-${noteInfo.player}`);
                hitZone.classList.add('miss');
                setTimeout(() => hitZone.classList.remove('miss'), 200);

                // Remove the note visually
                if (noteInfo.element && noteInfo.element.parentNode) {
                    noteInfo.element.style.opacity = '0';
                    setTimeout(() => {
                        if (noteInfo.element && noteInfo.element.parentNode) {
                            noteInfo.element.remove();
                        }
                    }, 200);
                }
                
                // Remove from active notes
                activeNotesMap.delete(noteIndex);
            }
        }

        animationFrameId = requestAnimationFrame(playerGameLoop);
    }
    
    function finishPlayerGame() {
        // Send game end message to score window
        if (dualMonitorMode) {
            try {
                const channel = new BroadcastChannel('joykado-score');
                channel.postMessage({
                    type: 'game-end'
                });
            } catch(e) {
                console.log('Could not send game end:', e);
            }
        }
        stopGame();
        
        // Calculate accuracy (count notes that were hit)
        const totalNotes = activeSong.beatmap ? activeSong.beatmap.length : 0;
        let hitNotes = 0;
        if (activeSong.beatmap) {
            activeSong.beatmap.forEach(note => {
                if (note.hit) hitNotes++;
            });
        }
        const accuracy = totalNotes > 0 ? (hitNotes / totalNotes) * 100 : 0;
        
        // Save score to leaderboard
        saveScore(score, maxCombo, accuracy);
        
        document.getElementById('result-title').innerText = "Game Over!";
        document.getElementById('result-message').innerHTML = `
            <p>Player: <b>${currentPlayerName}</b></p>
            <p>Score: <b>${score.toLocaleString()}</b></p>
            <p>Max Combo: <b>${maxCombo}</b></p>
            <p>Accuracy: <b>${accuracy.toFixed(1)}%</b></p>
            <p>Thanks for playing <b>${activeSong.name}</b>!</p>
        `;
        
        showScreen('screen-result');
    }

    // Initialize background music
    function initBackgroundMusic() {
        try {
            backgroundMusic = new Audio('beatkami.mp3');
            backgroundMusic.loop = true;
            backgroundMusic.volume = 0.3;
            // Try to play, but don't fail if autoplay is blocked
            backgroundMusic.play().catch(e => {
                console.log("Background music autoplay blocked, will play on user interaction:", e);
            });
        } catch(e) {
            console.log("Background music file not found:", e);
        }
    }
    
    // Enable audio on first user interaction
    document.addEventListener('click', () => {
        if (!audioContext) {
            initAudioContext();
            preloadSounds();
        }
        if (backgroundMusic && backgroundMusic.paused) {
            backgroundMusic.play().catch(e => console.log("Background music play error:", e));
        }
    }, { once: true });
    
    document.addEventListener('keydown', () => {
        if (!audioContext) {
            initAudioContext();
            preloadSounds();
        }
        if (backgroundMusic && backgroundMusic.paused) {
            backgroundMusic.play().catch(e => console.log("Background music play error:", e));
        }
    }, { once: true });
    
    // Initialize
    loadSongLibrary();
    initBackgroundMusic();
    setupEditorListeners(); // Setup editor file input listeners
    
    // Start with username entry screen (only if no saved username)
    const savedUsername = localStorage.getItem('joykado_username');
    if (savedUsername) {
        currentPlayerName = savedUsername;
        document.getElementById('player-name-text').textContent = currentPlayerName;
        showScreen('screen-menu');
        setupMenuNavigation('screen-menu');
    } else {
        openUsernameEntry();
    }
    
    // Username entry handler
    function handleUsernameEntryKeyDown(event) {
        if (!usernameEntryMode) return;
        
        const key = event.key.toLowerCase();
        event.preventDefault();
        
        if (key === 'enter' || key === ' ') {
            // Confirm username
            usernameEntryMode = false;
            document.removeEventListener('keydown', handleUsernameEntryKeyDown);
            playClickSound();
            // Save username to localStorage
            localStorage.setItem('joykado_username', currentPlayerName);
            // Update player name display and go to menu
            document.getElementById('player-name-text').textContent = currentPlayerName;
            showScreen('screen-menu');
            setupMenuNavigation('screen-menu');
            return;
        }
        
        if (key === 'a' || key === 'arrowleft') {
            // Move to previous position (left)
            usernameEntryIndex = Math.max(0, usernameEntryIndex - 1);
            updateUsernameDisplay();
            playButtonSound();
        } else if (key === 'd' || key === 'arrowright') {
            // Move to next position (right)
            usernameEntryIndex = Math.min(4, usernameEntryIndex + 1);
            updateUsernameDisplay();
            playButtonSound();
        } else if (key === 'w' || key === 'arrowup') {
            // Previous letter (up in alphabet)
            const currentLetter = currentPlayerName[usernameEntryIndex];
            const currentIndex = ALPHABET.indexOf(currentLetter);
            const newIndex = (currentIndex - 1 + ALPHABET.length) % ALPHABET.length;
            updateUsernameLetter(usernameEntryIndex, ALPHABET[newIndex]);
            playButtonSound();
        } else if (key === 's' || key === 'arrowdown') {
            // Next letter (down in alphabet)
            const currentLetter = currentPlayerName[usernameEntryIndex];
            const currentIndex = ALPHABET.indexOf(currentLetter);
            const newIndex = (currentIndex + 1) % ALPHABET.length;
            updateUsernameLetter(usernameEntryIndex, ALPHABET[newIndex]);
            playButtonSound();
        }
    }
    
    function openUsernameEntry() {
        usernameEntryMode = true;
        usernameEntryIndex = 0;
        currentPlayerName = 'AAAAA';
        updateUsernameDisplay();
        showScreen('screen-username-entry');
        document.addEventListener('keydown', handleUsernameEntryKeyDown);
    }
    
    function updateUsernameLetter(index, letter) {
        const nameArray = currentPlayerName.split('');
        nameArray[index] = letter;
        currentPlayerName = nameArray.join('');
        updateUsernameDisplay();
    }
    
    function updateUsernameDisplay() {
        const display = document.getElementById('username-display');
        const indexDisplay = document.getElementById('username-letter-index');
        
        if (display) {
            let html = '';
            for (let i = 0; i < 5; i++) {
                const letter = currentPlayerName[i] || 'A';
                const isActive = i === usernameEntryIndex;
                const style = isActive 
                    ? 'color: var(--beatkami-primary); text-shadow: 0 0 20px var(--beatkami-primary); transform: scale(1.2);'
                    : 'color: var(--hunter-green);';
                html += `<span style="${style}">${letter}</span>`;
            }
            display.innerHTML = html;
        }
        
        if (indexDisplay) {
            indexDisplay.textContent = usernameEntryIndex + 1;
        }
    }
</script>
</body>
</html>