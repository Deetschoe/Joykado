<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Joykado</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;700;900&display=swap');

        :root {
            --hit-zone-size: 140px;
            --note-speed: 2.5s; /* Time for note to fall */
            --wii-blue: #00A6EB; /* Bright Blue */
            --wii-red: #D73A49; /* Bright Red */
            --wii-green: #3AC75D; /* Bright Green for Success */
            --base-bg: #EAEAEA;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            font-family: 'Inter', sans-serif;
            background-color: var(--base-bg);
            background-image: radial-gradient(circle at center, rgba(255,255,255,0.8) 0%, rgba(200,200,200,0.5) 100%);
            overflow: hidden;
            user-select: none;
        }
        
        /* Hide all file inputs - they're triggered by buttons */
        input[type="file"] {
            display: none !important;
        }

        /* --- Screens --- */
        .screen {
            display: none;
            width: 100vw;
            height: 100vh;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: absolute;
            top: 0; left: 0;
            transition: opacity 0.5s;
            z-index: 1;
        }
        .screen.active { display: flex; }

        /* --- Wii Menu Grid --- */
        .wii-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 30px;
        }

        .channel-btn {
            width: 250px;
            height: 180px;
            background: white;
            border-radius: 25px;
            border: 5px solid #ccc;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275), box-shadow 0.2s, border-color 0.2s;
            box-shadow: 0 8px 15px rgba(0,0,0,0.1);
            color: #333;
        }

        .channel-btn:hover {
            transform: scale(1.05);
            border-color: var(--wii-blue);
            box-shadow: 0 0 25px rgba(0, 166, 235, 0.7), 0 8px 20px rgba(0,0,0,0.2);
            color: #1a5a92;
        }
        
        /* Menu item navigation */
        .menu-item {
            cursor: pointer;
            outline: none;
            min-width: 200px;
        }
        .menu-item:focus,
        .menu-item.selected {
            border-color: var(--wii-blue) !important;
            color: var(--wii-blue) !important;
            box-shadow: 0 0 15px rgba(0, 166, 235, 0.5), 0 4px 10px rgba(0,0,0,0.2) !important;
            transform: translateY(-2px);
        }
        
        .channel-icon { font-size: 50px; margin-bottom: 10px; }
        .channel-text { font-size: 22px; font-weight: 700; }

        /* --- Global Wii Button Style --- */
        .wii-button-pill {
            background: linear-gradient(145deg, #f0f0f0, #d4d4d4);
            border: 3px solid #ccc;
            padding: 12px 30px;
            border-radius: 50px;
            font-size: 18px;
            cursor: pointer;
            margin: 8px;
            transition: all 0.2s ease-out;
            color: #333;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            font-weight: 600;
        }
        .wii-button-pill:hover {
            border-color: var(--wii-blue);
            color: var(--wii-blue);
            box-shadow: 0 0 15px rgba(0, 166, 235, 0.5), 0 4px 10px rgba(0,0,0,0.2);
            transform: translateY(-2px);
        }
        .wii-button-pill:active { transform: translateY(0); box-shadow: 0 2px 4px rgba(0,0,0,0.2); }

        /* --- Game/Editor Interface --- */
        .game-area {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: flex-end; 
            padding-bottom: 5vh;
            background: #f0f0f0;
        }
        
        .player-lane {
            position: relative;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0 3%;
            width: 45%;
            max-width: 450px;
            border-left: 2px dashed rgba(0,0,0,0.1);
            border-right: 2px dashed rgba(0,0,0,0.1);
            box-sizing: border-box;
        }

        .hit-zone {
            width: var(--hit-zone-size);
            height: var(--hit-zone-size);
            border-radius: 50%;
            border: 8px solid var(--wii-blue);
            position: absolute;
            bottom: 5vh; 
            display: grid;
            grid-template-areas: ". up ." "left center right" ". down .";
            place-items: center;
            background: white;
            box-shadow: 0 0 20px rgba(0,0,0,0.1), inset 0 0 10px rgba(255,255,255,0.5);
            transition: border-color 0.1s, box-shadow 0.1s;
            box-sizing: border-box;
        }
        
        .hit-zone-label {
            position: absolute;
            bottom: -25px;
            font-weight: 700;
            color: #555;
            font-size: 16px;
        }

        /* Hit Zone Feedback */
        @keyframes shake {
            0%, 100% { transform: translate(0, 0); }
            20%, 60% { transform: translate(-5px, 0); }
            40%, 80% { transform: translate(5px, 0); }
        }
        .hit-zone.miss {
            animation: shake 0.2s;
            border-color: var(--wii-red) !important;
            box-shadow: 0 0 30px var(--wii-red) !important;
        }
        .hit-zone.good {
            border-color: var(--wii-green) !important;
            box-shadow: 0 0 30px var(--wii-green) !important;
        }

        .arrow-indicator {
            font-size: 36px;
            font-weight: 900;
            color: #ddd;
            transition: color 0.1s, transform 0.1s;
            padding: 5px;
            line-height: 1;
            text-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .arrow-up { grid-area: up; }
        .arrow-down { grid-area: down; }
        .arrow-left { grid-area: left; }
        .arrow-right { grid-area: right; }

        /* Active Arrow Feedback */
        .hit-zone.active-up .arrow-up { color: var(--wii-red); transform: scale(1.3); }
        .hit-zone.active-down .arrow-down { color: var(--wii-red); transform: scale(1.3); }
        .hit-zone.active-left .arrow-left { color: var(--wii-blue); transform: scale(1.3); }
        .hit-zone.active-right .arrow-right { color: var(--wii-blue); transform: scale(1.3); }

        /* --- Falling Notes --- */
        .falling-note {
            position: absolute;
            width: 45px; height: 45px;
            border-radius: 12px;
            border: 4px solid white;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
            display: flex; justify-content: center; align-items: center;
            font-size: 26px;
            font-weight: 700;
            top: -60px; /* Start above screen */
            transform: translateX(-50%);
            transition: top var(--note-speed) linear; 
            z-index: 50;
        }

        .note-up, .note-down { background: var(--wii-red); color: white; }
        .note-left, .note-right { background: var(--wii-blue); color: white; }
        
        /* Lane positioning for 1P/2P */
        .note-up { left: 50%; } 
        .note-down { left: 50%; } 
        .note-left { left: 50%; } 
        .note-right { left: 50%; } 

        /* Floating Score Text Feedback */
        .score-feedback {
            position: absolute;
            bottom: calc(5vh + var(--hit-zone-size) / 2);
            font-size: 40px;
            font-weight: 900;
            opacity: 0;
            pointer-events: none;
            text-shadow: 2px 2px 5px rgba(0,0,0,0.3);
            animation: float-up 1s ease-out forwards;
            z-index: 100;
        }
        .feedback-good { color: var(--wii-green); }
        .feedback-miss { color: var(--wii-red); }
        .feedback-combo { 
            color: #FFD700;
            font-size: 50px;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.8), 0 0 20px rgba(255, 215, 0, 0.6);
        }

        @keyframes float-up {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-50px); }
        }
        
        @keyframes sparkle {
            0%, 100% { opacity: 0; transform: scale(0) rotate(0deg); }
            50% { opacity: 1; transform: scale(1) rotate(180deg); }
        }
        
        .sparkle {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #FFD700;
            border-radius: 50%;
            pointer-events: none;
            z-index: 200;
            box-shadow: 0 0 10px #FFD700;
            animation: sparkle 0.6s ease-out forwards;
        }
        
        /* Volume slider styling */
        #music-volume {
            -webkit-appearance: none;
            appearance: none;
            background: #d1d5db;
            outline: none;
        }
        
        #music-volume::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--wii-blue);
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        #music-volume::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--wii-blue);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

    </style>
</head>
<body>

    <!-- === CUSTOM MESSAGE BOX === -->
    <div id="custom-message-box" class="fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-white p-6 rounded-2xl shadow-2xl text-center z-[1000] border-4 border-amber-500 max-w-lg hidden">
        <div id="message-content" class="mb-4 text-lg font-medium text-gray-700"></div>
        <div class="flex justify-center space-x-4">
            <button class="wii-button-pill bg-blue-100 border-blue-400 text-blue-800 hover:bg-blue-200" onclick="hideMessage(false)">OK</button>
            <button class="wii-button-pill bg-red-100 border-red-400 text-red-800 hover:bg-red-200" id="message-cancel-btn" style="display: none;" onclick="hideMessage(true)">Cancel</button>
        </div>
    </div>

    <!-- === COUNTDOWN OVERLAY === -->
    <div id="countdown-overlay" class="fixed inset-0 bg-black/70 flex justify-center items-center z-[500] hidden">
        <div id="countdown-number" class="text-[200px] text-white font-black drop-shadow-[0_0_40px_rgba(0,166,235,1)]">3</div>
    </div>

    <!-- === SCREEN 1: MAIN MENU === -->
    <div id="screen-menu" class="screen active">
        <h1 class="text-4xl text-gray-500 font-light mb-10 tracking-widest">Joykado Game</h1>
        <div id="main-menu-options" class="flex flex-col gap-4 items-center">
            <div class="menu-item wii-button-pill bg-blue-50 text-blue-700 border-blue-300" data-action="play" tabindex="0">
                üéß Play Songs
            </div>
            <div class="menu-item wii-button-pill bg-gray-100 text-gray-600 border-gray-300" data-action="options" tabindex="0">
                ‚öôÔ∏è Options
            </div>
        </div>
        <p class="text-xs text-gray-400 mt-10">Use WASD/Arrows to navigate, Enter to select</p>
    </div>
    
    <!-- === SCREEN: CATEGORY SELECTION === -->
    <div id="screen-category-select" class="screen">
        <div class="bg-white p-10 rounded-3xl shadow-2xl max-w-2xl w-[90%] text-center">
            <h2 class="text-3xl text-gray-700 font-bold mb-6">Select Category</h2>
            <div id="category-list" class="flex flex-col gap-3 w-full max-h-96 overflow-y-auto p-4 bg-gray-50 rounded-lg border border-gray-200">
                <!-- Categories will be injected here -->
            </div>
            <br>
            <div class="menu-item wii-button-pill bg-gray-100 text-gray-600 border-gray-300" data-action="back-to-menu" tabindex="0">Back</div>
        </div>
    </div>

    <!-- === SCREEN 2: CREATOR SETUP (Uploads) === -->
    <div id="screen-setup" class="screen">
        <div class="bg-white p-10 rounded-3xl shadow-2xl max-w-lg w-full text-center">
            <h2 id="setup-title" class="text-3xl text-gray-700 font-bold mb-4">Create New Beatmap</h2>
            <p class="text-gray-500 mb-6">First, upload your music file (use mouse).</p>
            
            <button class="wii-button-pill bg-blue-50 text-blue-700 border-blue-300" onclick="document.getElementById('file-input-mp3').click()">
                Select MP3 / Audio File
            </button>
            <input type="file" id="file-input-mp3" accept="audio/*" style="display: none;">
            <div id="mp3-filename" class="mt-4 text-blue-600 font-medium">No file selected.</div>

            <div id="song-name-input" class="mt-6 hidden">
                <input type="text" id="new-song-name" placeholder="Enter Song Name (Required)" 
                       class="p-3 border-2 border-gray-300 rounded-lg w-full text-center focus:border-wii-blue focus:outline-none">
            </div>
            
            <div id="category-select" class="mt-4 hidden">
                <label class="block text-sm font-semibold text-gray-700 mb-2">Category:</label>
                <select id="song-category" class="p-2 border-2 border-gray-300 rounded-lg w-full text-center focus:border-wii-blue focus:outline-none">
                    <option value="HipHop">HipHop</option>
                    <option value="Anime">Anime</option>
                    <option value="JPOP">JPOP</option>
                    <option value="Rock">Rock</option>
                    <option value="Misc">Misc</option>
                </select>
            </div>
            
            <div id="difficulty-select" class="mt-4 hidden">
                <label class="block text-sm font-semibold text-gray-700 mb-2">Difficulty:</label>
                <select id="song-difficulty" class="p-2 border-2 border-gray-300 rounded-lg w-full text-center focus:border-wii-blue focus:outline-none">
                    <option value="Easy">Easy</option>
                    <option value="Medium" selected>Medium</option>
                    <option value="Hard">Hard</option>
                </select>
            </div>

            <br>
            <button id="start-editor-btn" class="wii-button-pill bg-green-50 text-green-700 border-green-300 font-bold hidden">
                Start Recording Beat
            </button>
            <br>
            <div class="menu-item wii-button-pill bg-gray-100 text-gray-600 border-gray-300" data-action="back-to-options" tabindex="0">Back to Options</div>
        </div>
    </div>

    <!-- === SCREEN: SONG SELECTION === -->
    <div id="screen-song-select" class="screen">
        <div class="bg-white p-10 rounded-3xl shadow-2xl max-w-2xl w-[90%] text-center">
            <h2 class="text-3xl text-gray-700 font-bold mb-2" id="category-title">Select a Song</h2>
            <p class="text-sm text-gray-500 mb-4" id="category-subtitle"></p>
            <div id="song-list-container" class="flex flex-col gap-3 w-full max-h-80 overflow-y-auto p-4 bg-gray-50 rounded-lg border border-gray-200">
                <!-- Songs will be injected here -->
                <div class="text-gray-500 py-4" id="no-songs-message">Loading songs...</div>
            </div>

            <br>
            <div class="menu-item wii-button-pill bg-gray-100 text-gray-600 border-gray-300" data-action="back-to-category" tabindex="0">Back</div>
        </div>
    </div>
    
    <!-- === SCREEN: OPTIONS === -->
    <div id="screen-options" class="screen">
        <div class="bg-white p-10 rounded-3xl shadow-2xl max-w-lg w-full text-center">
            <h2 class="text-3xl text-gray-700 font-bold mb-6">Options</h2>
            
            <div class="mb-6">
                <div class="menu-item wii-button-pill bg-purple-50 text-purple-700 border-purple-300 relative" id="volume-menu-item" tabindex="0" style="min-height: 80px; display: flex; align-items: center; justify-content: center;">
                    <div class="flex flex-col items-center w-full">
                        <div class="text-lg font-semibold mb-2">Music Volume</div>
                        <div class="w-full max-w-xs mx-auto flex items-center gap-2">
                            <span class="text-xs text-gray-500">‚óÄ</span>
                            <div class="flex-1 h-8 bg-gray-300 rounded-full overflow-hidden border-2 border-gray-400 relative">
                                <div class="h-full bg-blue-600 transition-all duration-100" id="options-music-volume-bar" style="width: 50%"></div>
                                <div class="absolute inset-0 flex items-center justify-center text-sm font-bold text-gray-700" id="options-volume-text">50%</div>
                            </div>
                            <span class="text-xs text-gray-500">‚ñ∂</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="mb-6">
                <div class="menu-item wii-button-pill bg-blue-50 text-blue-700 border-blue-300" data-action="open-creator" tabindex="0">
                    üìù Beatmap Creator
                </div>
            </div>
            
            <div class="mb-6">
                <p class="text-gray-500 mb-3 text-sm">Upload external files (use mouse):</p>
                <div class="flex justify-center flex-wrap gap-2">
                    <button class="wii-button-pill text-indigo-700 border-indigo-300 text-sm" onclick="document.getElementById('file-input-external-mp3').click()">Upload MP3</button>
                    <button class="wii-button-pill text-orange-700 border-orange-300 text-sm" onclick="document.getElementById('file-input-map').click()">Upload Beatmap</button>
                </div>
                <input type="file" id="file-input-external-mp3" accept="audio/*" style="display: none;">
                <input type="file" id="file-input-map" accept=".json" style="display: none;">
                <div id="external-upload-status" class="mt-2 text-sm text-blue-600 font-medium"></div>
            </div>
            
            <div class="menu-item wii-button-pill bg-gray-100 text-gray-600 border-gray-300" data-action="back-to-menu" tabindex="0">Back to Menu</div>
        </div>
    </div>


    <!-- === SCREEN 6: PLAYER SETUP (Player Count) === -->
    <div id="screen-player-setup" class="screen">
        <div class="bg-white p-10 rounded-3xl shadow-2xl max-w-lg w-full text-center">
            <h2 class="text-3xl text-gray-700 font-bold mb-4" id="player-setup-song-title"></h2>
            <p class="text-gray-500 mb-6">Choose the number of players:</p>

            <div class="flex justify-center space-x-4">
                <div class="menu-item wii-button-pill text-blue-700 border-blue-300" data-action="set-player-1" tabindex="0">1 Player</div>
                <div class="menu-item wii-button-pill text-red-700 border-red-300" data-action="set-player-2" tabindex="0">2 Players</div>
            </div>

            <div id="player-count-display" class="mt-4 text-xl font-bold text-gray-600"></div>

            <br>
            <button id="start-player-btn" class="wii-button-pill bg-green-50 text-green-700 border-green-300 font-bold hidden">
                Start Game
            </button>
            <br>
            <button class="wii-button-pill bg-gray-100 text-gray-600 border-gray-300" onclick="openSongSelection()">Change Song</button>
        </div>
    </div>


    <!-- === SCREEN 3: GAME / EDITOR INTERFACE === -->
    <div id="screen-game" class="screen">
        <div class="absolute top-0 left-0 right-0 h-16 bg-white/95 border-b border-gray-300 flex items-center justify-between px-6 z-10">
            <div id="mode-display" class="font-bold text-lg text-gray-700"></div>
            <div class="flex items-center w-1/3 mx-8">
                <div class="progress-container w-full h-6 bg-gray-300 rounded-full overflow-hidden shadow-inner border-2 border-gray-400">
                    <div class="progress-fill h-full w-0 bg-blue-600 transition-all duration-100" id="progress-bar"></div>
                </div>
            </div>
            <div id="time-display" class="font-bold text-lg text-gray-700">0:00</div>
        </div>
        
        <div id="score-display" class="absolute top-20 right-6 text-2xl font-bold text-gray-600 z-10">SCORE: 0</div>
        <div id="combo-display" class="absolute top-20 left-6 text-2xl font-bold text-gray-600 z-10">COMBO: 0</div>

        <div class="game-area" id="game-area">
            <!-- Player 1 Lane -->
            <div class="player-lane" id="player-lane-1">
                <div class="hit-zone" id="hit-zone-1">
                    <div class="arrow-indicator arrow-up" style="grid-area: up;">‚ñ≤</div>
                    <div class="arrow-indicator arrow-left" style="grid-area: left;">‚óÄ</div>
                    <div class="arrow-indicator arrow-down" style="grid-area: down;">‚ñº</div>
                    <div class="arrow-indicator arrow-right" style="grid-area: right;">‚ñ∂</div>
                    <div class="hit-zone-label">P1</div>
                </div>
                <!-- Floating Feedback for P1 is created here -->
            </div>

            <!-- Player 2 Lane (Hidden by default, shown in 2P mode) -->
            <div class="player-lane" id="player-lane-2" style="display:none;">
                <div class="hit-zone" id="hit-zone-2">
                    <div class="arrow-indicator arrow-up" style="grid-area: up;">‚ñ≤</div>
                    <div class="arrow-indicator arrow-left" style="grid-area: left;">‚óÄ</div>
                    <div class="arrow-indicator arrow-down" style="grid-area: down;">‚ñº</div>
                    <div class="arrow-indicator arrow-right" style="grid-area: right;">‚ñ∂</div>
                    <div class="hit-zone-label">P2</div>
                </div>
                 <!-- Floating Feedback for P2 is created here -->
            </div>
        </div>

        <!-- Volume Control and Quit button in corner -->
        <div id="game-controls" class="absolute top-4 right-4 flex items-center gap-3 z-20 hidden">
            <div class="flex flex-col items-center bg-white/90 rounded-lg p-2 shadow-lg border border-gray-300">
                <label class="text-xs text-gray-600 font-medium mb-1">Music</label>
                <input type="range" id="music-volume" min="0" max="100" value="50" 
                       class="w-20 h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer"
                       oninput="updateMusicVolume(this.value)">
            </div>
            <button class="wii-button-pill bg-red-100 text-red-700 border-red-300 text-sm" onclick="askQuit()">Quit</button>
        </div>
        <div id="instruction-text" class="absolute top-24 left-1/2 -translate-x-1/2 text-base text-gray-500 font-medium z-10 text-center px-4"></div>
    </div>

    <!-- === SCREEN 4: EXPORT / RESULTS === -->
    <div id="screen-result" class="screen">
        <div class="bg-white p-10 rounded-3xl shadow-2xl max-w-lg w-full text-center">
            <h2 id="result-title" class="text-3xl text-gray-700 font-bold mb-4"></h2>
            <p id="result-message" class="text-gray-500 mb-6"></p>
            <br>
            <div class="menu-item wii-button-pill bg-green-50 text-green-700 border-green-300 font-bold" data-action="back-to-menu" tabindex="0">Return to Menu</div>
        </div>
    </div>

<script>
    // === GLOBAL VARIABLES ===
    let appMode = 'menu'; // menu, editor, player, select, setup, results
    let playerCount = 0;
    let mainAudio = new Audio();
    let recordedNotes = []; // Stores { time: number, direction: string, player: number }
    let playNotes = []; // The beatmap to play
    let activeSong = null; // { name, mp3Url, beatmap }
    let isPlaying = false;
    let animationFrameId;
    let lastTime;

    // Timing Constants
    const NOTE_SPEED = 2.5; // Time (seconds) for note to fall
    const HIT_WINDOW = 0.15; // Hit window (seconds) before and after the beat time
    const SPAWN_OFFSET_TIME = NOTE_SPEED; // Notes spawn 'NOTE_SPEED' seconds before they should be hit

    // Game state
    let notesIndex1P = 0;  // Index for spawning P1 notes
    let notesIndex2P = 0;  // Index for spawning P2 notes
    let score = 0;
    let combo = 0;
    let maxCombo = 0;
    let activeNotesMap = new Map(); // Track active notes: noteIndex -> {element, noteData, player}
    let gameStartTime = 0; // Track when the game actually started
    let lastComboMilestone = 0; // Track last combo milestone shown
    
    // Navigation state
    let currentMenuIndex = 0;
    let currentMenuItems = [];
    let navigationMode = 'menu'; // 'menu', 'game', 'options'
    let currentCategory = null;
    let allSongs = []; // All loaded songs by category
    const CATEGORIES = ['HipHop', 'Anime', 'JPOP', 'Rock', 'Misc'];
    
    // Sound effects for hit feedback - use AudioContext for better compatibility
    let soundBuffers = {};
    let audioContext = null;
    
    // Initialize audio context when user interacts
    function initAudioContext() {
        if (!audioContext) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        return audioContext;
    }
    
    // Load sound files
    async function loadSound(url, direction) {
        try {
            if (!audioContext || audioContext.state === 'closed') {
                initAudioContext();
            }
            
            const response = await fetch(url);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            
            const arrayBuffer = await response.arrayBuffer();
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            soundBuffers[direction] = audioBuffer;
            console.log(`Loaded sound: ${direction}`);
        } catch (error) {
            console.error(`Failed to load sound ${url}, using fallback:`, error);
            // Fallback to HTML5 Audio
            try {
                const audio = new Audio(url);
                audio.volume = 0.6;
                soundBuffers[direction] = audio;
            } catch (fallbackError) {
                console.error(`Fallback audio also failed for ${direction}:`, fallbackError);
            }
        }
    }
    
    // Function to play hit sound
    async function playHitSound(direction) {
        try {
            // Ensure audio context is initialized and running
            if (!audioContext) {
                initAudioContext();
            }
            
            if (audioContext.state === 'suspended') {
                await audioContext.resume();
            }
            
            const buffer = soundBuffers[direction];
            if (!buffer) {
                console.warn(`Sound buffer not loaded for: ${direction}`);
                return;
            }
            
            // If it's an AudioBuffer (Web Audio API)
            if (buffer instanceof AudioBuffer) {
                const source = audioContext.createBufferSource();
                const gainNode = audioContext.createGain();
                gainNode.gain.value = 0.6;
                source.buffer = buffer;
                source.connect(gainNode);
                gainNode.connect(audioContext.destination);
                source.start(0);
            } else if (buffer instanceof HTMLAudioElement || buffer instanceof Audio) {
                // Fallback to HTML5 Audio
                const clone = buffer.cloneNode();
                clone.volume = 0.6;
                clone.play().catch(e => console.log("Sound play error:", e));
            }
        } catch (error) {
            console.error("Error playing sound:", error);
        }
    }
    
    // Preload all sounds after first user interaction
    function preloadSounds() {
        initAudioContext();
        loadSound('sounds/1.wav', 'up');
        loadSound('sounds/2.wav', 'down');
        loadSound('sounds/3.wav', 'left');
        loadSound('sounds/4.wav', 'right');
    }
    
    // Song Library (Stored in localStorage for persistence)
    let songLibrary = [];
    
    // Load song library from localStorage on startup
    function loadSongLibrary() {
        const stored = localStorage.getItem('songLibrary');
        if (stored) {
            songLibrary = JSON.parse(stored);
        }
    }
    
    // Save song library to localStorage
    function saveSongLibrary() {
        localStorage.setItem('songLibrary', JSON.stringify(songLibrary));
    } 
    // Example Song (If you don't use Firestore, this keeps state between sessions)
    // songLibrary.push({ name: "Demo Track", mp3Url: "https://placehold.co/100x100/00A6EB/white?text=Demo", beatmap: [{time: 1.0, direction: 'up', player: 1}, {time: 1.5, direction: 'right', player: 1}, ...] });

    // Note and Key Maps
    const NOTE_MAP = {
        'up': { symbol: '‚ñ≤', colorClass: 'note-up', stream: 'up' },
        'down': { symbol: '‚ñº', colorClass: 'note-down', stream: 'down' },
        'left': { symbol: '‚óÄ', colorClass: 'note-left', stream: 'left' },
        'right': { symbol: '‚ñ∂', colorClass: 'note-right', stream: 'right' }
    };
    
    const KEY_MAP_1P = {
        'w': 'up', 'arrowup': 'up',
        'd': 'right', 'arrowright': 'right',
        's': 'down', 'arrowdown': 'down',
        'a': 'left', 'arrowleft': 'left'
    };

    const KEY_MAP_2P = {
        'i': 'up', 
        'l': 'right', 
        'k': 'down', 
        'j': 'left'
    };

    // === UTILITIES ===

    // Music volume control
    function updateMusicVolume(value) {
        const volume = value / 100;
        mainAudio.volume = volume;
        // Store volume preference
        localStorage.setItem('musicVolume', volume);
    }
    
    // Load saved volume preference
    function loadMusicVolume() {
        const savedVolume = localStorage.getItem('musicVolume');
        if (savedVolume !== null) {
            const volume = parseFloat(savedVolume);
            mainAudio.volume = volume;
            document.getElementById('music-volume').value = volume * 100;
        } else {
            mainAudio.volume = 0.5; // Default 50%
            document.getElementById('music-volume').value = 50;
        }
    }

    function formatTime(seconds) {
        const min = Math.floor(seconds / 60);
        const sec = Math.floor(seconds % 60).toString().padStart(2, '0');
        return `${min}:${sec}`;
    }

    // Floating Feedback Animation
    function showFeedback(text, type, player) {
        const lane = document.getElementById(`player-lane-${player}`);
        const feedback = document.createElement('div');
        feedback.className = `score-feedback ${type === 'good' ? 'feedback-good' : 'feedback-miss'}`;
        feedback.innerText = text;
        lane.appendChild(feedback);

        // Position it above the hit zone
        const hitZoneBottom = document.getElementById(`hit-zone-${player}`).offsetTop;
        feedback.style.bottom = `${lane.clientHeight - hitZoneBottom + 20}px`;

        // Clean up after animation
        setTimeout(() => {
            feedback.remove();
        }, 1000);
    }
    
    // Show combo milestone (10x, 20x, etc.)
    function showComboMilestone(comboCount, comboPoints, player) {
        const lane = document.getElementById(`player-lane-${player}`);
        const hitZone = document.getElementById(`hit-zone-${player}`);
        
        // Create combo milestone feedback
        const milestone = document.createElement('div');
        milestone.className = 'score-feedback feedback-combo';
        milestone.innerHTML = `${comboCount}x COMBO!<br><span style="font-size: 0.7em;">+${comboPoints} points</span>`;
        lane.appendChild(milestone);
        
        // Position it above the hit zone
        const hitZoneBottom = hitZone.offsetTop;
        milestone.style.bottom = `${lane.clientHeight - hitZoneBottom + 20}px`;
        milestone.style.textAlign = 'center';
        
        // Clean up after animation
        setTimeout(() => {
            milestone.remove();
        }, 2000);
    }
    
    // Create sparkles animation
    function createSparkles(player) {
        const lane = document.getElementById(`player-lane-${player}`);
        const hitZone = document.getElementById(`hit-zone-${player}`);
        const hitZoneRect = hitZone.getBoundingClientRect();
        const laneRect = lane.getBoundingClientRect();
        
        // Create multiple sparkles
        for (let i = 0; i < 8; i++) {
            const sparkle = document.createElement('div');
            sparkle.className = 'sparkle';
            
            // Random position around hit zone
            const angle = (Math.PI * 2 * i) / 8;
            const distance = 60 + Math.random() * 40;
            const x = hitZoneRect.left - laneRect.left + hitZoneRect.width / 2 + Math.cos(angle) * distance;
            const y = hitZoneRect.top - laneRect.top + hitZoneRect.height / 2 + Math.sin(angle) * distance;
            
            sparkle.style.left = `${x}px`;
            sparkle.style.top = `${y}px`;
            sparkle.style.animationDelay = `${i * 0.05}s`;
            
            lane.appendChild(sparkle);
            
            // Clean up after animation
            setTimeout(() => {
                if (sparkle.parentNode) {
                    sparkle.remove();
                }
            }, 600);
        }
    }

    // === MESSAGE BOX UTILITY ===
    let messageResolve = null;

    function showMessage(content, showCancel = false) {
        document.getElementById('message-content').innerHTML = content;
        const cancelBtn = document.getElementById('message-cancel-btn');
        cancelBtn.style.display = showCancel ? 'inline-block' : 'none';
        
        document.getElementById('custom-message-box').style.display = 'flex';

        return new Promise(resolve => {
            messageResolve = resolve;
        });
    }

    function hideMessage(isCancel = false) {
        document.getElementById('custom-message-box').style.display = 'none';
        if (messageResolve) {
            messageResolve(!isCancel); // Resolve with true for OK, false for Cancel
            messageResolve = null;
        }
    }
    
    /**
     * Waits for the HTMLMediaElement to be ready to play (canplaythrough).
     */
    function loadAudioPromise(audioElement) {
        return new Promise((resolve, reject) => {
            // Already ready
            if (audioElement.readyState >= 3) { 
                resolve();
                return;
            }
            
            // Wait for enough data to play without interruption
            audioElement.addEventListener('canplaythrough', resolve, { once: true });
            
            // Handle error
            audioElement.addEventListener('error', (e) => {
                console.error("Audio element error:", e);
                reject(new Error("Audio load error"));
            }, { once: true });
        });
    }

    // === NAVIGATION & RESET ===
    function showScreen(id) {
        document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
        document.getElementById(id).classList.add('active');
        
        // Show/hide game controls based on screen
        const gameControls = document.getElementById('game-controls');
        if (id === 'screen-game') {
            gameControls.classList.remove('hidden');
            navigationMode = 'game';
            document.removeEventListener('keydown', handleMenuNavigation);
        } else {
            gameControls.classList.add('hidden');
            navigationMode = 'menu';
            setupMenuNavigation(id);
        }
    }
    
    // Setup keyboard navigation for menus
    function setupMenuNavigation(screenId) {
        currentMenuIndex = 0;
        currentMenuItems = Array.from(document.querySelectorAll(`#${screenId} .menu-item`));
        
        if (currentMenuItems.length > 0) {
            currentMenuItems[0].classList.add('selected');
            currentMenuItems[0].focus();
        }
        
        document.addEventListener('keydown', handleMenuNavigation);
    }
    
    // Handle menu navigation with keyboard
    function handleMenuNavigation(event) {
        if (navigationMode !== 'menu') return;
        if (appMode === 'player' || appMode === 'editor') return; // Don't interfere with game
        
        const key = event.key.toLowerCase();
        
        // Enter key to select
        if (key === 'enter' || key === ' ') {
            event.preventDefault();
            if (currentMenuItems[currentMenuIndex]) {
                // Play click sound when actually selecting
                playClickSound();
                const action = currentMenuItems[currentMenuIndex].dataset.action;
                handleMenuAction(action);
            }
            return;
        }
        
        // WASD or Arrow keys for navigation
        let moved = false;
        if (key === 'w' || key === 'arrowup') {
            event.preventDefault();
            const oldIndex = currentMenuIndex;
            currentMenuIndex = Math.max(0, currentMenuIndex - 1);
            if (oldIndex !== currentMenuIndex) {
                moved = true;
                playButtonSound(); // Play sound when navigating between items
            }
        } else if (key === 's' || key === 'arrowdown') {
            event.preventDefault();
            const oldIndex = currentMenuIndex;
            currentMenuIndex = Math.min(currentMenuItems.length - 1, currentMenuIndex + 1);
            if (oldIndex !== currentMenuIndex) {
                moved = true;
                playButtonSound(); // Play sound when navigating between items
            }
        } else if (key === 'a' || key === 'arrowleft') {
            event.preventDefault();
            // Volume down in options (when volume item is selected)
            if (appMode === 'options' && currentMenuItems[currentMenuIndex] && currentMenuItems[currentMenuIndex].id === 'volume-menu-item') {
                adjustVolume(-5);
            }
            return;
        } else if (key === 'd' || key === 'arrowright') {
            event.preventDefault();
            // Volume up in options (when volume item is selected)
            if (appMode === 'options' && currentMenuItems[currentMenuIndex] && currentMenuItems[currentMenuIndex].id === 'volume-menu-item') {
                adjustVolume(5);
            }
            return;
        }
        
        if (moved && currentMenuItems.length > 0) {
            currentMenuItems.forEach(item => item.classList.remove('selected'));
            currentMenuItems[currentMenuIndex].classList.add('selected');
            currentMenuItems[currentMenuIndex].focus();
        }
    }
    
    // Handle menu actions
    function handleMenuAction(action) {
        switch(action) {
            case 'play':
                openCategorySelection();
                break;
            case 'options':
                openOptions();
                break;
            case 'back-to-menu':
                goToMenu();
                break;
            case 'back-to-category':
                openCategorySelection();
                break;
            case 'open-creator':
                openCreatorSetup();
                break;
            case 'back-to-options':
                openOptions();
                break;
            default:
                if (action.startsWith('category-')) {
                    const category = action.replace('category-', '');
                    selectCategory(category);
                } else if (action.startsWith('song-')) {
                    const songIndex = parseInt(action.replace('song-', ''));
                    selectSongFromList(songIndex);
                } else if (action === 'set-player-1') {
                    setPlayerCount(1);
                } else if (action === 'set-player-2') {
                    setPlayerCount(2);
                } else if (action === 'start-game') {
                    if (playerCount > 0) {
                        preparePlayerGame(playerCount);
                    }
                }
        }
    }
    
    // Volume adjustment in options
    function adjustVolume(delta) {
        const volumeSlider = document.getElementById('music-volume');
        if (!volumeSlider) return;
        
        let currentValue = parseInt(volumeSlider.value) || 50;
        currentValue = Math.max(0, Math.min(100, currentValue + delta));
        volumeSlider.value = currentValue;
        updateMusicVolume(currentValue);
        
        // Update visual bar
        const bar = document.getElementById('options-music-volume-bar');
        const text = document.getElementById('options-volume-text');
        if (bar) bar.style.width = currentValue + '%';
        if (text) text.textContent = currentValue + '%';
    }

    function goToMenu() {
        stopGame();
        appMode = 'menu';
        resetInputs();
        currentCategory = null;
        playNextSound(); // Page change sound
        showScreen('screen-menu');
    }
    
    function openCategorySelection() {
        appMode = 'select';
        playNextSound(); // Page change sound
        showScreen('screen-category-select');
        renderCategories();
    }
    
    function openOptions() {
        appMode = 'options';
        playNextSound(); // Page change sound
        showScreen('screen-options');
        // Set current volume display
        const volumeSlider = document.getElementById('music-volume');
        if (volumeSlider) {
            const value = parseInt(volumeSlider.value) || 50;
            const bar = document.getElementById('options-music-volume-bar');
            const text = document.getElementById('options-volume-text');
            if (bar) bar.style.width = value + '%';
            if (text) text.textContent = value + '%';
        }
    }
    
    // Render category selection
    function renderCategories() {
        const container = document.getElementById('category-list');
        container.innerHTML = '';
        
        CATEGORIES.forEach((category, index) => {
            const categoryDiv = document.createElement('div');
            categoryDiv.className = 'menu-item wii-button-pill bg-white text-gray-700 border-gray-300 text-lg';
            categoryDiv.dataset.action = `category-${category}`;
            categoryDiv.tabIndex = 0;
            categoryDiv.textContent = category;
            container.appendChild(categoryDiv);
        });
        
        setupMenuNavigation('screen-category-select');
    }
    
    // Select category and load songs
    async function selectCategory(category) {
        currentCategory = category;
        
        // Load songs from category folder
        await loadSongsFromCategory(category);
        
        playNextSound(); // Page change sound
        showScreen('screen-song-select');
        document.getElementById('category-title').textContent = `${category} Songs`;
        document.getElementById('category-subtitle').textContent = `Select a song to play`;
        renderSongList();
    }
    
    // Play button sound when navigating between menu items (hovering)
    function playButtonSound() {
        try {
            const buttonSound = new Audio('sounds/button.wav');
            buttonSound.volume = 0.5;
            buttonSound.play().catch(e => console.log("Button sound play error:", e));
        } catch(e) {
            console.log("Button sound file not found:", e);
        }
    }
    
    // Play click sound when actually selecting a menu item
    function playClickSound() {
        try {
            const clickSound = new Audio('sounds/click.wav');
            clickSound.volume = 0.5;
            clickSound.play().catch(e => console.log("Click sound play error:", e));
        } catch(e) {
            console.log("Click sound file not found:", e);
        }
    }
    
    // Play next sound when changing pages/screens
    function playNextSound() {
        try {
            const nextSound = new Audio('sounds/next.wav');
            nextSound.volume = 0.5;
            nextSound.play().catch(e => console.log("Next sound play error:", e));
        } catch(e) {
            console.log("Next sound file not found:", e);
        }
    }
    
    // Load songs from category folder
    async function loadSongsFromCategory(category) {
        allSongs = [];
        
        // Try to load songs from the category folder
        // Since we can't directly list directory contents in browser, we'll use a naming convention
        // Songs should be named: category_songname.mp3 with category_songname_beatmap.json
        
        // For now, we'll check localStorage for songs, or try common patterns
        // In a real implementation, you'd need a server endpoint or pre-defined list
        
        // Check if we have songs in localStorage
        const storedSongs = JSON.parse(localStorage.getItem('songLibrary') || '[]');
        const categorySongs = storedSongs.filter(song => 
            song.category === category || 
            song.name.toLowerCase().includes(category.toLowerCase())
        );
        
        // Also try to load from common file patterns
        // This is a placeholder - in production you'd need server-side file listing
        allSongs = categorySongs;
        
        // If no songs found, show message
        if (allSongs.length === 0) {
            console.log(`No songs found for category: ${category}`);
        }
    }

    async function askQuit() {
        if (appMode === 'editor' && recordedNotes.length > 0) {
            const shouldSave = await showMessage("You have unsaved beats. Do you want to finish and download your map?", true);
            if (shouldSave) {
                finishEditor();
                return;
            }
        }
        goToMenu();
    }

    function stopGame() {
        mainAudio.pause();
        mainAudio.currentTime = 0;
        cancelAnimationFrame(animationFrameId);
        isPlaying = false;
        document.removeEventListener('keydown', handleKeyDown);
        document.removeEventListener('keyup', handleKeyUp);
        document.removeEventListener('keydown', handleEditorKeyDown); // Ensure editor listener is removed
        
        // Clear falling notes if any
        document.querySelectorAll('.falling-note').forEach(note => note.remove());
        
        // Clear active notes map
        activeNotesMap.clear();
    }

    function resetInputs() {
        // Reset File Inputs (keep mainAudio.src for player persistence until a new file is chosen)
        document.getElementById('file-input-mp3').value = '';
        document.getElementById('file-input-external-mp3').value = '';
        document.getElementById('file-input-map').value = '';
        document.getElementById('mp3-filename').innerText = 'No file selected.';
        document.getElementById('external-upload-status').innerText = '';
        document.getElementById('new-song-name').value = '';
        document.getElementById('song-name-input').style.display = 'none';

        recordedNotes = [];
        playNotes = [];
        notesIndex1P = 0;
        notesIndex2P = 0;
        score = 0;
        combo = 0;
        maxCombo = 0;
        lastComboMilestone = 0;
        playerCount = 0;
        activeNotesMap.clear();
        gameStartTime = 0;
    }

    // === COUNTDOWN LOGIC ===
    async function startCountdown(callback) {
        document.getElementById('countdown-overlay').style.display = 'flex';
        const countdownNumber = document.getElementById('countdown-number');
        
        // Custom CSS for pulse animation (to be added to <style> block for full fix)
        /*
        @keyframes pulse {
            0% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.3); opacity: 1; }
            100% { transform: scale(1); opacity: 0.8; }
        }
        */
        
        for (let i = 3; i >= 1; i--) {
            countdownNumber.innerText = i;
            // Reset pulse animation
            countdownNumber.style.animation = 'none';
            void countdownNumber.offsetWidth; 
            countdownNumber.style.animation = 'pulse 1s ease-out';
            await new Promise(resolve => setTimeout(resolve, 1000));
        }

        countdownNumber.innerText = "GO!";
        await new Promise(resolve => setTimeout(resolve, 500));
        document.getElementById('countdown-overlay').style.display = 'none';
        
        callback();
    }
    
    // === EDITOR MODE LOGIC ===
    function openCreatorSetup() {
        appMode = 'setup';
        activeSong = null; 
        showScreen('screen-setup');
        document.getElementById('category-select').style.display = 'none';
        document.getElementById('difficulty-select').style.display = 'none';
        checkEditorReady();
    }

    document.getElementById('file-input-mp3').addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (file) {
            document.getElementById('mp3-filename').innerText = "Music: " + file.name;
            const url = URL.createObjectURL(file);
            mainAudio.src = url;
            document.getElementById('song-name-input').style.display = 'block';
        } else {
             document.getElementById('song-name-input').style.display = 'none';
             mainAudio.src = '';
        }
        checkEditorReady();
    });

    document.getElementById('new-song-name').addEventListener('input', checkEditorReady);

    function checkEditorReady() {
        const mp3Ready = mainAudio.src !== '';
        const nameReady = document.getElementById('new-song-name').value.trim() !== '';
        
        if (mp3Ready && nameReady) {
            document.getElementById('category-select').style.display = 'block';
            document.getElementById('difficulty-select').style.display = 'block';
            document.getElementById('start-editor-btn').style.display = 'inline-block';
            document.getElementById('start-editor-btn').onclick = prepareEditor;
        } else {
             document.getElementById('category-select').style.display = 'none';
             document.getElementById('difficulty-select').style.display = 'none';
             document.getElementById('start-editor-btn').style.display = 'none';
        }
    }

    // *** FIX APPLIED HERE ***
    async function prepareEditor() {
        const songName = document.getElementById('new-song-name').value.trim();
        if (!songName) {
            await showMessage("Please enter a name for the song before starting.");
            return;
        }

        if (!mainAudio.src) {
            await showMessage("Please select an audio file first.");
            return;
        }
        
        // 1. Wait for audio to be ready (Can Play)
        try {
            await showMessage("Loading audio, please wait...");
            await loadAudioPromise(mainAudio);
            hideMessage(false); // Hide the loading message
        } catch (error) {
            hideMessage(false); 
            console.error("Audio load failed:", error);
            await showMessage("Failed to load audio file. Please ensure it is a valid format.");
            return;
        }

        const category = document.getElementById('song-category').value;
        const difficulty = document.getElementById('song-difficulty').value;
        
        activeSong = {
            name: songName,
            mp3Url: mainAudio.src,
            beatmap: [],
            category: category,
            difficulty: difficulty
        };
        
        // 2. Start countdown, then start game logic
        startCountdown(startEditorGame);
    }
    
    // *** FIX APPLIED HERE ***
    function startEditorGame() {
        appMode = 'editor';
        showScreen('screen-game');
        document.getElementById('mode-display').innerText = `CREATOR MODE: ${activeSong.name}`;
        document.getElementById('instruction-text').innerText = "Press keys to the beat! (P1 Only)";
        document.getElementById('instruction-text').style.display = 'block';
        
        // Preload sounds on first interaction
        preloadSounds();
        loadMusicVolume();
        
        playerCount = 1;
        document.getElementById('player-lane-2').style.display = 'none';
        
        recordedNotes = [];
        
        // 1. Setup the listener to start the loop *only* when the audio starts playing
        mainAudio.onplaying = () => {
            isPlaying = true;
            animationFrameId = requestAnimationFrame(editorGameLoop);
        };
        
        // 2. Setup the listener for when the song naturally ends
        mainAudio.onended = finishEditor;

        // 3. Play the audio, which triggers the onplaying listener once successful
        mainAudio.play().catch(e => {
             console.error("Audio playback error:", e);
             showMessage("Error: Audio playback failed. The browser might be blocking autoplay. Try reloading and clicking faster.", false);
        });
        
        document.addEventListener('keydown', handleEditorKeyDown);
    }

    function handleEditorKeyDown(event) {
        const key = event.key.toLowerCase();
        let direction = KEY_MAP_1P[key];

        if (direction && !event.repeat) {
            if (!isPlaying) {
                 console.log("Audio not playing yet, key press ignored.");
                 showMessage("The music hasn't started yet! Wait for the countdown to finish.", false);
                 return;
            }
            
            // Only P1 keys are used in creator mode
            recordedNotes.push({
                time: mainAudio.currentTime, // Correctly uses audio time
                direction: direction,
                player: 1 
            });
            
            // Play hit sound
            playHitSound(direction);
            
            // Visual feedback on hit zone
            const hitZone = document.getElementById('hit-zone-1');
            hitZone.classList.add('good');
            hitZone.classList.add(`active-${direction}`);
            setTimeout(() => {
                hitZone.classList.remove('good');
                hitZone.classList.remove(`active-${direction}`);
            }, 100);
        }
    }

    function editorGameLoop(timestamp) {
        if (!lastTime) lastTime = timestamp;
        // const elapsed = timestamp - lastTime;
        lastTime = timestamp;

        if (mainAudio.paused) return; // Audio paused, stop loop

        // Update UI
        const currentTime = mainAudio.currentTime;
        document.getElementById('time-display').innerText = formatTime(currentTime);
        document.getElementById('progress-bar').style.width = `${(currentTime / mainAudio.duration) * 100}%`;

        // If in editor mode, we can optionally show note creation feedback
        
        animationFrameId = requestAnimationFrame(editorGameLoop);
    }


    function finishEditor() {
        stopGame();
        
        // 1. Add/Update Song in Library
        activeSong.beatmap = recordedNotes;
        
        const existingIndex = songLibrary.findIndex(s => s.name === activeSong.name);
        if (existingIndex > -1) {
            songLibrary[existingIndex] = activeSong;
        } else {
            songLibrary.push(activeSong);
        }
        
        // Save to localStorage
        saveSongLibrary();

        document.getElementById('result-title').innerText = "Beatmap Creation Complete!";
        document.getElementById('result-message').innerHTML = `Your map for <b>${activeSong.name}</b> (${recordedNotes.length} notes) has been saved to the Song Library and downloaded as a JSON file.`;
        
        // 2. Automatic Download Beatmap (include metadata)
        const beatmapData = {
            notes: recordedNotes,
            metadata: {
                name: activeSong.name,
                category: activeSong.category,
                difficulty: activeSong.difficulty
            }
        };
        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(beatmapData));
        const downloadAnchorNode = document.createElement('a');
        downloadAnchorNode.setAttribute("href", dataStr);
        downloadAnchorNode.setAttribute("download", `${activeSong.name.replace(/\s/g, '_')}_beatmap.json`);
        document.body.appendChild(downloadAnchorNode);
        downloadAnchorNode.click();
        downloadAnchorNode.remove();
        
        // 3. Show Result Screen
        showScreen('screen-result');
        setupMenuNavigation('screen-result');
    }
    
    // === PLAYER MODE SETUP: SONG SELECTION/UPLOAD ===
    
    let externalMp3Url = null;
    let externalMp3Name = null;
    let externalMapData = null;
    
    function openSongSelection() {
        appMode = 'select';
        showScreen('screen-song-select');
        renderSongList();
        
        // Clear external upload status
        externalMp3Url = null;
        externalMapData = null;
        document.getElementById('external-upload-status').innerText = '';
    }

    async function handleExternalMp3Upload(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        externalMp3Name = file.name.replace(/\.[^/.]+$/, "");
        externalMp3Url = URL.createObjectURL(file);
        
        document.getElementById('external-upload-status').innerHTML = `MP3: <b>${file.name}</b> loaded. Upload map file or choose a local song.`;
        checkExternalReady();
    }

    async function handleExternalMapUpload(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = async (ev) => {
            try {
                const parsed = JSON.parse(ev.target.result);
                // Handle both old format (array) and new format (with metadata)
                if (Array.isArray(parsed)) {
                    externalMapData = parsed;
                } else if (parsed.notes && Array.isArray(parsed.notes)) {
                    externalMapData = parsed.notes;
                    // Store metadata if available
                    if (parsed.metadata) {
                        externalMapMetadata = parsed.metadata;
                    }
                } else {
                    throw new Error("Invalid format");
                }
                document.getElementById('external-upload-status').innerHTML = `Map: <b>${file.name}</b> loaded. Ready to start!`;
                checkExternalReady();
            } catch(err) {
                await showMessage("Invalid map file format. Please ensure it's a valid JSON array.");
                externalMapData = null;
            }
        };
        reader.readAsText(file);
    }
    
    let externalMapMetadata = null;

    function checkExternalReady() {
        if (externalMp3Url && externalMapData) {
            // Found both, create temporary active song and go to player setup
            activeSong = {
                name: externalMp3Name || externalMapMetadata?.name || 'External Song',
                mp3Url: externalMp3Url,
                beatmap: externalMapData.sort((a, b) => a.time - b.time), // Ensure sorted
                category: externalMapMetadata?.category || 'Misc',
                difficulty: externalMapMetadata?.difficulty || 'Medium'
            };
            openPlayerSetup();
        }
    }
    
    document.getElementById('file-input-external-mp3').addEventListener('change', handleExternalMp3Upload);
    document.getElementById('file-input-map').addEventListener('change', handleExternalMapUpload);


    function renderSongList() {
        const container = document.getElementById('song-list-container');
        container.innerHTML = '';

        const songsToShow = currentCategory ? allSongs : songLibrary;
        
        if (songsToShow.length === 0) {
            document.getElementById('no-songs-message').textContent = currentCategory 
                ? `No songs found in ${currentCategory} category.` 
                : 'No songs created yet. Use the "Beatmap Creator" in Options!';
            document.getElementById('no-songs-message').style.display = 'block';
            return;
        }
        document.getElementById('no-songs-message').style.display = 'none';

        songsToShow.forEach((song, index) => {
            const card = document.createElement('div');
            card.className = 'menu-item song-card flex justify-between items-center p-4 bg-white rounded-xl shadow-md hover:shadow-lg border border-gray-200';
            card.dataset.action = `song-${index}`;
            card.tabIndex = 0;
            
            const difficulty = song.difficulty || 'Medium';
            const difficultyColor = {
                'Easy': 'text-green-600',
                'Medium': 'text-yellow-600',
                'Hard': 'text-red-600'
            }[difficulty] || 'text-gray-600';

            const detailsHtml = `
                <div class="text-left flex-1">
                    <div class="font-bold text-lg text-gray-800">${song.name}</div>
                    <div class="text-sm text-gray-500">${song.beatmap ? song.beatmap.length : 0} notes</div>
                    <div class="text-xs ${difficultyColor} font-semibold mt-1">${difficulty}</div>
                </div>
                <div class="text-xl text-wii-blue">‚ñ∂</div>
            `;
            card.innerHTML = detailsHtml;
            container.appendChild(card);
        });
        
        setupMenuNavigation('screen-song-select');
    }
    
    function selectSongFromList(index) {
        const songsToShow = currentCategory ? allSongs : songLibrary;
        if (songsToShow[index]) {
            selectSong(songsToShow[index]);
        }
    }

    function selectSong(song) {
        activeSong = song;
        openPlayerSetup();
    }

    // === PLAYER MODE SETUP: PLAYER COUNT ===
    function openPlayerSetup() {
        appMode = 'player_setup';
        showScreen('screen-player-setup');
        const title = activeSong.name + (activeSong.difficulty ? ` (${activeSong.difficulty})` : '');
        document.getElementById('player-setup-song-title').innerText = title;
        playerCount = 0; // Reset player count
        document.getElementById('player-count-display').innerText = 'Use WASD to select, Enter to confirm.';
        document.getElementById('start-player-btn').style.display = 'none';
        
        // Setup keyboard navigation for player count selection
        setupMenuNavigation('screen-player-setup');
    }

    function setPlayerCount(count) {
        playerCount = count;
        document.getElementById('player-count-display').innerText = `${count} Player${count > 1 ? 's' : ''} selected. Press Enter to start.`;
        document.getElementById('start-player-btn').style.display = 'inline-block';
        document.getElementById('start-player-btn').onclick = () => preparePlayerGame(count);
        
        // Make start button selectable
        const startBtn = document.getElementById('start-player-btn');
        startBtn.className = 'menu-item wii-button-pill bg-green-50 text-green-700 border-green-300 font-bold';
        startBtn.dataset.action = 'start-game';
        startBtn.tabIndex = 0;
        setupMenuNavigation('screen-player-setup');
    }
    
    function preparePlayerGame(count) {
        mainAudio.src = activeSong.mp3Url;
        playNotes = activeSong.beatmap.slice().sort((a, b) => a.time - b.time); // Sort and copy
        startCountdown(() => startPlayerGame(count));
    }

    // === PLAYER MODE GAME LOGIC ===
    function startPlayerGame(count) {
        appMode = 'player';
        showScreen('screen-game');
        document.getElementById('mode-display').innerText = `PLAYING: ${activeSong.name}`;
        document.getElementById('instruction-text').innerText = "Hit the notes when they reach the target!";
        document.getElementById('instruction-text').style.display = 'block';
        
        // Preload sounds on first interaction
        preloadSounds();
        loadMusicVolume();
        
        // Reset/Setup game state
        notesIndex1P = 0;
        notesIndex2P = 0;
        score = 0;
        combo = 0;
        maxCombo = 0;
        lastComboMilestone = 0;
        activeNotesMap.clear(); // Clear active notes
        document.getElementById('score-display').innerText = 'SCORE: 0';
        document.getElementById('combo-display').innerText = 'COMBO: 0';
        
        // Reset all notes to not hit
        playNotes.forEach(note => {
            note.hit = false;
        });
        
        // Set game start time after a brief delay to allow notes to spawn
        gameStartTime = -1.0; // Start checking after 1 second

        // Setup lanes
        const lane2 = document.getElementById('player-lane-2');
        if (count === 2) {
            lane2.style.display = 'flex';
        } else {
            lane2.style.display = 'none';
        }

        // Start playing
        mainAudio.play().then(() => {
            // Set game start time when audio actually starts
            gameStartTime = mainAudio.currentTime;
        });
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);
        mainAudio.onended = finishPlayerGame;
        
        // Fallback: set start time to current audio time
        gameStartTime = 0;
        
        animationFrameId = requestAnimationFrame(playerGameLoop);
    }

    function handleKeyDown(event) {
        const key = event.key.toLowerCase();
        let direction, player, hitZone;

        if (KEY_MAP_1P[key]) {
            direction = KEY_MAP_1P[key];
            player = 1;
            hitZone = document.getElementById('hit-zone-1');
        } else if (playerCount === 2 && KEY_MAP_2P[key]) {
            direction = KEY_MAP_2P[key];
            player = 2;
            hitZone = document.getElementById('hit-zone-2');
        } else {
            return;
        }

        if (!event.repeat) {
            // Apply visual active state
            hitZone.classList.add(`active-${direction}`);

            // Perform hit check
            checkHit(direction, player);
        }
    }
    
    function handleKeyUp(event) {
        const key = event.key.toLowerCase();
        let direction, player, hitZone;

        if (KEY_MAP_1P[key]) {
            direction = KEY_MAP_1P[key];
            player = 1;
            hitZone = document.getElementById('hit-zone-1');
        } else if (playerCount === 2 && KEY_MAP_2P[key]) {
            direction = KEY_MAP_2P[key];
            player = 2;
            hitZone = document.getElementById('hit-zone-2');
        } else {
            return;
        }

        // Remove visual active state
        hitZone.classList.remove(`active-${direction}`);
    }

    function checkHit(direction, player) {
        const currentTime = mainAudio.currentTime;
        let bestNote = null;
        let bestTimeDiff = Infinity;
        let foundNoteInWindow = false;

        // Check all active notes for this player
        for (let [noteIndex, noteInfo] of activeNotesMap.entries()) {
            const note = noteInfo.noteData;
            
            // Only check notes for this player
            if (noteInfo.player !== player) {
                continue;
            }
            
            // Skip already hit notes
            if (note.hit) {
                continue;
            }
            
            // Check if note is within hit window
            const timeDiff = Math.abs(note.time - currentTime);
            
            if (timeDiff <= HIT_WINDOW) {
                foundNoteInWindow = true;
                
                // If direction matches, this is a potential hit
                if (note.direction === direction) {
                    // Find the closest matching note in the window
                    if (timeDiff < bestTimeDiff) {
                        bestTimeDiff = timeDiff;
                        bestNote = { noteIndex, noteInfo, note };
                    }
                }
            }
        }
        
        // If we found a matching note, it's a HIT!
        if (bestNote) {
            const { noteIndex, noteInfo, note } = bestNote;
            
            // Mark as hit
            note.hit = true;
            
            // Remove from active notes map
            activeNotesMap.delete(noteIndex);
            
            // Play hit sound
            playHitSound(direction);
            
            combo++;
            const comboPoints = combo * 10;
            score += 100 + comboPoints;
            maxCombo = Math.max(maxCombo, combo);
            
            // Show combo milestone at 10, 20, 30, etc.
            if (combo >= 10 && combo % 10 === 0 && combo > lastComboMilestone) {
                lastComboMilestone = combo;
                showComboMilestone(combo, comboPoints, player);
                
                // Add sparkles for milestone combos above 25
                if (combo >= 25) {
                    createSparkles(player);
                }
            } else {
                showFeedback("GOOD!", 'good', player);
            }
            
            document.getElementById('score-display').innerText = 'SCORE: ' + score;
            document.getElementById('combo-display').innerText = 'COMBO: ' + combo;

            // Remove the note element from the DOM
            if (noteInfo.element && noteInfo.element.parentNode) {
                noteInfo.element.remove();
            }
            
            // Visual feedback
            const hitZone = document.getElementById(`hit-zone-${player}`);
            hitZone.classList.add('good');
            setTimeout(() => hitZone.classList.remove('good'), 100);
            
            return; // Successfully hit, exit
        }
        
        // Only show MISS if there was a note in the window but wrong direction
        // Also check if enough time has passed since game start (prevent initial false misses)
        const timeSinceStart = mainAudio.currentTime - gameStartTime;
        if (foundNoteInWindow && timeSinceStart > 1.0) {
            // Wrong direction pressed (only after 1 second of gameplay)
            combo = 0;
            lastComboMilestone = 0;
            document.getElementById('combo-display').innerText = 'COMBO: 0';
            
            const hitZone = document.getElementById(`hit-zone-${player}`);
            hitZone.classList.add('miss');
            setTimeout(() => hitZone.classList.remove('miss'), 200);
        }
        // If foundNoteInWindow is false, do nothing - player pressed key but no note in window
    }
    
    function spawnNote(noteData, index) {
        const { time, direction, player } = noteData;
        
        // Skip if already hit (shouldn't happen, but safety check)
        if (noteData.hit) {
            return;
        }
        
        const lane = document.getElementById(`player-lane-${player}`);
        const hitZone = document.getElementById(`hit-zone-${player}`);
        
        const noteElement = document.createElement('div');
        noteElement.id = `note-${index}`;
        noteElement.className = `absolute falling-note ${NOTE_MAP[direction].colorClass}`;
        noteElement.innerText = NOTE_MAP[direction].symbol;
        
        // Calculate lane position (center of the lane)
        noteElement.style.left = '50%';
        
        // Set up transition
        noteElement.style.transition = 'top ' + NOTE_SPEED + 's linear';

        // The note starts at the top and its transition targets the hit zone's center Y position
        const hitZoneY = hitZone.offsetTop + hitZone.offsetHeight / 2;
        const noteHeight = noteElement.offsetHeight || 45; // Default size if not rendered yet
        
        // The final 'top' position to center the note on the hit zone
        const finalTop = hitZoneY - noteHeight / 2;

        // Apply starting position (top of the lane)
        noteElement.style.top = '-60px'; // Start off-screen
        
        lane.appendChild(noteElement);
        
        // Force reflow to ensure CSS transition starts from the initial position
        void noteElement.offsetWidth;

        // Now, set the target position to start the animation
        noteElement.style.top = `${finalTop}px`;
        
        // Store the target Y for miss checking
        noteElement.dataset.hitTime = time;
        noteElement.dataset.noteIndex = index;
        
        // Add to active notes map
        activeNotesMap.set(index, {
            element: noteElement,
            noteData: noteData,
            player: player
        });
    }

    function playerGameLoop(timestamp) {
        if (!lastTime) lastTime = timestamp;
        // const elapsed = timestamp - lastTime;
        lastTime = timestamp;

        if (mainAudio.paused) {
            cancelAnimationFrame(animationFrameId);
            return;
        }

        const currentTime = mainAudio.currentTime;
        document.getElementById('time-display').innerText = formatTime(currentTime);
        document.getElementById('progress-bar').style.width = `${(currentTime / mainAudio.duration) * 100}%`;


        // 1. Check for notes that should be spawned
        // Spawn all notes that should be visible (for both players in sequence)
        for (let i = 0; i < playNotes.length; i++) {
            const note = playNotes[i];
            
            // Skip if already spawned or hit
            if (activeNotesMap.has(i) || note.hit) {
                continue;
            }
            
            // Skip if note is too far in the future
            if (note.time > currentTime + SPAWN_OFFSET_TIME) {
                continue;
            }
            
            // Spawn the note if it's time
            if (note.time <= currentTime + SPAWN_OFFSET_TIME) {
                spawnNote(note, i);
            }
        }
        
        // 2. Check for notes that were missed (passed the hit window without being hit)
        for (let [noteIndex, noteInfo] of activeNotesMap.entries()) {
            const note = noteInfo.noteData;
            
            // Skip if already hit
            if (note.hit) {
                continue;
            }
            
            // If the note's hit time is before the current time minus the hit window, it's a miss
            // Only check for misses after the game has been running for at least 1.5 seconds
            // This prevents false misses at the very start
            const timeSinceStart = currentTime - gameStartTime;
            if (note.time < currentTime - HIT_WINDOW && currentTime > 1.5) {
                // MISSED!
                note.hit = true; // Mark as hit so it doesn't get checked again
                
                combo = 0;
                lastComboMilestone = 0;
                document.getElementById('combo-display').innerText = 'COMBO: 0';
                
                showFeedback("MISS", 'miss', noteInfo.player);
                const hitZone = document.getElementById(`hit-zone-${noteInfo.player}`);
                hitZone.classList.add('miss');
                setTimeout(() => hitZone.classList.remove('miss'), 200);

                // Remove the note visually
                if (noteInfo.element && noteInfo.element.parentNode) {
                    noteInfo.element.style.opacity = '0';
                    setTimeout(() => {
                        if (noteInfo.element && noteInfo.element.parentNode) {
                            noteInfo.element.remove();
                        }
                    }, 200);
                }
                
                // Remove from active notes
                activeNotesMap.delete(noteIndex);
            }
        }

        animationFrameId = requestAnimationFrame(playerGameLoop);
    }
    
    function finishPlayerGame() {
        stopGame();
        
        document.getElementById('result-title').innerText = "Game Over!";
        document.getElementById('result-message').innerHTML = `
            <p>Score: <b>${score}</b></p>
            <p>Max Combo: <b>${maxCombo}</b></p>
            <p>Thanks for playing <b>${activeSong.name}</b>!</p>
        `;
        
        showScreen('screen-result');
    }

    // Initialize audio context on first user interaction
    document.addEventListener('click', () => {
        if (!audioContext) {
            initAudioContext();
            preloadSounds();
        }
    }, { once: true });
    
    document.addEventListener('keydown', () => {
        if (!audioContext) {
            initAudioContext();
            preloadSounds();
        }
    }, { once: true });
    
    // Initialize
    loadSongLibrary();
    goToMenu();
</script>
</body>
</html>